# ==============================================================================
# CLUSTERING JERÁRQUICO: MIN, MAX, AVG Y EFECTO DEL JITTER
# ==============================================================================

# ------------------------------------------------------------------------------
# CARGA DE LIBRERÍA Y DEFINICIÓN DE LOS DATOS
# ------------------------------------------------------------------------------

# Se carga la librería que contiene la función agglomerative_clustering
# install.packages("UAHDataScienceUC")  # Descomentar si no está instalado
library(UAHDataScienceUC)

# Se define una matriz con 15 observaciones bidimensionales (15 filas, 2 columnas).
# Cada fila representa un punto en el plano (x, y).
datos <- matrix(c(
  0.89, 2.94, 
  4.36, 5.21,
  3.75, 1.12,
  6.25, 3.14,
  4.1,  1.8,
  3.9,  4.27
), ncol = 2, byrow = TRUE)

# Se asignan nombres de fila "1", "2", ..., "15" para identificar fácilmente
# cada observación en salidas y gráficos.
rownames(datos) <- as.character(1:nrow(datos))

# ------------------------------------------------------------------------------
# GENERACIÓN DE JITTER (RUIDO PEQUEÑO) SOBRE LOS DATOS
# ------------------------------------------------------------------------------

# Se fija la semilla para que la generación de ruido sea reproducible
# (cada ejecución con esta semilla produce el mismo ruido).
set.seed(123)

# Se crea una matriz de ruido del mismo tamaño que 'datos',
# con valores uniformes entre -0.03 y 0.03 en cada coordenada.
ruido <- matrix(runif(length(datos), -0.03, 0.03), ncol = 2)

# Se suman los pequeños ruidos a los datos originales, obteniendo 'datos_jitter'.
# Esto simula jitter: ligeras perturbaciones de la posición de cada punto.
datos_jitter <- datos + ruido

# ============================================
# MIN (single-link)
# ============================================

# ------------------------------------------------------------------------------
# CLUSTERING JERÁRQUICO CON ENLACE MÍNIMO (SIN JITTER)
# ------------------------------------------------------------------------------

# Se aplica clustering jerárquico aglomerativo con:
# - data = datos (puntos originales)
# - proximity = "single" (enlace mínimo: distancia entre clústeres
#   definida como la mínima distancia entre pares de puntos de ambos clústeres)
# - distance_method = "euclidean" (distancia euclídea)
# - learn y waiting se dejan para controlar el comportamiento interno de la función.
cl_min_original <- agglomerative_clustering(
  data = datos,
  proximity = "single",
  distance_method = "euclidean",
  learn = TRUE,
  waiting = FALSE
)

# ------------------------------------------------------------------------------
# CLUSTERING JERÁRQUICO CON ENLACE MÍNIMO (CON JITTER)
# ------------------------------------------------------------------------------

# Se repite el mismo procedimiento, pero sobre los datos perturbados 'datos_jitter'.
# Esto permite que grupos de 3 o más valores con la misma proximidad puedan ser
# distinguidos los clusters que se vayan formando.
cl_min_jitter <- agglomerative_clustering(
  data = datos_jitter,
  proximity = "single",
  distance_method = "euclidean",
  learn = TRUE,
  waiting = FALSE
)

# ------------------------------------------------------------------------------
# OBTENCIÓN DE PARTICIONES EN 3 CLÚSTERES (MIN)
# ------------------------------------------------------------------------------

# Se convierte el objeto devuelto por agglomerative_clustering a un objeto 'hclust'
# y se corta el dendrograma en k = 3 clústeres para los datos originales.
# El resultado es un vector que indica a qué clúster pertenece cada observación.
cutree(as.hclust(cl_min_original), k = 3)

# Se hace lo mismo para el clustering con jitter, permitiendo comparar
# las asignaciones de clúster entre la versión original y la perturbada.
# De esta forma se puede visualizar si el ruido añadido a los datos ha perjudicado
# el resultado esperado. Para que todo esté correcto, los datos deben continuar 
# estando en el cluster que se obtuvo para los datos originales.
cutree(as.hclust(cl_min_jitter),   k = 3)

# ============================================
# MAX (complete-link)
# ============================================

# ------------------------------------------------------------------------------
# CLUSTERING JERÁRQUICO CON ENLACE MÁXIMO (SIN JITTER)
# ------------------------------------------------------------------------------

# Se aplica clustering jerárquico con:
# - proximity = "complete" (enlace completo: la distancia entre clústeres
#   es la mayor distancia entre pares de puntos de ambos clústeres).
# Este criterio tiende a formar clústeres más compactos y bien separados,
# menos sensibles a cadenas de puntos que el single-link.
cl_max_original <- agglomerative_clustering(
  data = datos,
  proximity = "complete",
  distance_method = "euclidean",
  learn = TRUE,
  waiting = FALSE
)

# ============================================
# AVG (average-link)
# ============================================

# ------------------------------------------------------------------------------
# CLUSTERING JERÁRQUICO CON ENLACE PROMEDIO (SIN JITTER)
# ------------------------------------------------------------------------------

# Se aplica clustering jerárquico con:
# - proximity = "average" (enlace promedio: la distancia entre clústeres
#   es la media de las distancias entre todos los pares de puntos de ambos clústeres).
# Este método suele dar un compromiso entre single-link y complete-link,
# generando clústeres ni tan encadenados ni tan compactos como complete-link.
cl_avg_original <- agglomerative_clustering(
  data = datos,
  proximity = "average",
  distance_method = "euclidean",
  learn = TRUE,
  waiting = FALSE
)

# ============================================
# VISUALIZACIÓN DE LOS DENDROGRAMAS
# ============================================

# ------------------------------------------------------------------------------
# PREPARACIÓN DEL DISPOSITIVO GRÁFICO
# ------------------------------------------------------------------------------

# Se cierra cualquier dispositivo gráfico abierto previamente,
# para evitar conflictos con nuevas ventanas de gráficos.
dev.off()

# ------------------------------------------------------------------------------
# DENDROGRAMA PARA MAX (complete-link)
# ------------------------------------------------------------------------------

# Se abre una nueva ventana gráfica (en Windows) para mostrar el dendrograma
# del clustering con enlace completo sobre los datos originales.
windows()
plot(as.hclust(cl_max_original), main = "MAX (complete-link)")

# ------------------------------------------------------------------------------
# DENDROGRAMA PARA AVG (average-link)
# ------------------------------------------------------------------------------

# Se abre otra ventana gráfica para el dendrograma de enlace promedio
# con los datos originales.
windows()
plot(as.hclust(cl_avg_original), main = "AVG (average-link)")

# ------------------------------------------------------------------------------
# DENDROGRAMA PARA MIN (single-link) CON JITTER
# ------------------------------------------------------------------------------

# Finalmente, se abre una tercera ventana gráfica para mostrar el dendrograma
# del clustering con enlace mínimo aplicado a los datos con jitter.
windows()
plot(as.hclust(cl_min_jitter), main = "MIN (single-link) con jitter")




# ============================================
# CORRELACIÓN COPHENÉTICA MIN, MAX, AVG
# ============================================

# 1) Distancias originales entre los puntos ------------------------------
# Calcula la matriz de distancias euclídeas entre todas las parejas de
# observaciones del conjunto 'datos'. Esta será la "referencia real"
# que queremos que el dendrograma reproduzca lo mejor posible.
dist_original <- dist(datos, method = "euclidean")
d_vec <- as.vector(dist_original)  # pasamos a vector numérico

# 2) Conversión de los resultados a objetos hclust -----------------------
# Los objetos devueltos por agglomerative_clustering se convierten al
# formato estándar 'hclust', que es el que necesitan las funciones
# cophenetic() y cutree() de R.
hc_min <- as.hclust(cl_min_original)  # árbol jerárquico para MIN
hc_max <- as.hclust(cl_max_original)  # árbol jerárquico para MAX
hc_avg <- as.hclust(cl_avg_original)  # árbol jerárquico para AVG

# 3) Distancias cophenéticas de cada dendrograma -------------------------
# cophenetic() calcula, para cada pareja de puntos, la altura del nodo
# donde se fusionan en el dendrograma. Es decir, la “distancia”
# que induce el árbol, no la distancia euclídea original.
coph_min <- cophenetic(hc_min);  dh_min <- as.vector(coph_min)
coph_max <- cophenetic(hc_max);  dh_max <- as.vector(coph_max)
coph_avg <- cophenetic(hc_avg);  dh_avg <- as.vector(coph_avg)

# 4) Función para la correlación cophenética (definición explícita) ------
# Varianza poblacional (divide entre N)
var_pop <- function(x) {
  x <- as.vector(x)
  m <- mean(x)
  sum((x - m)^2) / length(x)
}

# Covarianza poblacional (divide entre N)
cov_pop <- function(x, y) {
  x <- as.vector(x); y <- as.vector(y)
  mx <- mean(x); my <- mean(y)
  sum((x - mx) * (y - my)) / length(x)
}

# Desviación típica poblacional
sd_pop <- function(x) sqrt(var_pop(x))

# Implementa la fórmula poblacional:
#   ρ = Cov_N(D, D̂) / (sd_N(D) * sd_N(D̂))
coph_corr <- function(d, dh) {
  d  <- as.vector(d)   # distancias originales
  dh <- as.vector(dh)  # distancias cophenéticas

  num <- cov_pop(d, dh)          # Covarianza poblacional
  sd_d  <- sd_pop(d)             # sd poblacional de D
  sd_dh <- sd_pop(dh)            # sd poblacional de D̂
  den <- sd_d * sd_dh            # Producto de desviaciones típicas poblacionales

  # Ver valores intermedios
  cat("Covarianza_N(D, D̂):", num, "\n")
  cat("sd_N(D):", sd_d, "  sd_N(D̂):", sd_dh, "\n")
  cat("Denominador sd_N(D)*sd_N(D̂):", den, "\n")

  rho <- num / den               # Coeficiente de correlación cophenética (poblacional)
  cat("ρ (cophenético, poblacional):", rho, "\n\n")

  return(rho)
}

# 5) Cálculo de la correlación cophenética para cada método --------------
cor_min <- coph_corr(d_vec, dh_min)
cor_max <- coph_corr(d_vec, dh_max)
cor_avg <- coph_corr(d_vec, dh_avg)

# 6) Mostrar resultados en consola ---------------------------------------
# Se imprimen las correlaciones cophenéticas para cada criterio de enlace,
# de forma que puedas comparar rápidamente cuál de los tres métodos
# (MIN, MAX o AVG) reproduce mejor la estructura de distancias.
cat("Cophenetic MIN :", cor_min, "\n")
cat("Cophenetic MAX :", cor_max, "\n")
cat("Cophenetic AVG :", cor_avg, "\n")
