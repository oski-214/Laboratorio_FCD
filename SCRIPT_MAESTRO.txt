# ==============================================================================
# MASTER SCRIPT: FUNDAMENTOS DE CIENCIA DE DATOS (PL1)
# ==============================================================================

# ==============================================================================
# EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO GUIADO (Satélites de Urano)
# Usa funciones estándar de R base.
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO (SATÉLITES URANO)\n")
cat("********************************************************************\n")

# --- 1. Carga de datos ---
# Asegúrate de tener 'satelites.txt' en tu directorio de trabajo (setwd)
# Contenido esperado de satelites.txt:
# nombre radio
# Cordelia 13
# Ofelia 16
# ...
s <- read.table("satelites.txt", header = TRUE)
print(">> Conjunto de datos original:")
print(s)

# --- 2. Ordenación ---
# Orden ascendente por radio
so_asc <- s[order(s$radio), ]
print(">> Datos ordenados (ascendente) por Radio:")
print(so_asc)

# Orden descendente por radio
so_desc <- s[rev(order(s$radio)), ]
print(">> Datos ordenados (descendente) por Radio:")
print(so_desc)

# --- 3. Medidas de Dispersión Básicas (Rango) ---
rango_val <- max(s$radio) - min(s$radio)
cat("\n>> Rango del radio:", rango_val, "km\n")

# --- 4. Tablas de Frecuencias ---
frec_abs <- table(s$radio)                # Frecuencia absoluta
frec_abs_acum <- cumsum(frec_abs)         # Frecuencia absoluta acumulada
frec_rel <- frec_abs / length(s$radio)    # Frecuencia relativa
frec_rel_acum <- cumsum(frec_rel)         # Frecuencia relativa acumulada

# Visualización compacta en data frame
tabla_frec <- data.frame(
  Radio = names(frec_abs),
  ni = as.integer(frec_abs),
  Ni = as.integer(frec_abs_acum),
  fi = round(as.numeric(frec_rel), 3),
  Fi = round(as.numeric(frec_rel_acum), 3)
)
cat("\n>> Tabla de Frecuencias Completa (Radio):\n")
print(tabla_frec)

# --- 5. Medidas de Tendencia Central ---
media_r <- mean(s$radio)
mediana_r <- median(s$radio)

cat("\n>> Medidas de Tendencia Central:\n")
cat("   Media:", round(media_r, 2), "km\n")
cat("   Mediana:", mediana_r, "km\n")

# --- 6. Medidas de Dispersión y Posición ---
# Nota: var() y sd() en R calculan la versión muestral (n-1)
var_r <- var(s$radio)
sd_r <- sd(s$radio)
# Cuartiles (25%, 50%, 75%)
cuartiles <- quantile(s$radio, probs = c(0.25, 0.50, 0.75))

cat("\n>> Medidas de Dispersión y Posición:\n")
cat("   Varianza (muestral):", round(var_r, 2), "\n")
cat("   Desviación Típica (muestral):", round(sd_r, 2), "km\n")
cat("   Cuartiles:\n")
print(cuartiles)




# ==============================================================================
# EJERCICIO 1.2: Análisis de asociación.
# ==============================================================================

# --- Carga del paquete arules (instalar si es necesario) ---
# install.packages("arules")  # Descomentar si no está instalado
library(arules)

# --- Creación de la matriz binaria de cestas de compra ---
muestra <- Matrix(
  c(1,1,0,1,1,
    1,1,1,1,0,
    1,1,0,1,0,
    1,0,1,1,0,
    1,1,0,0,0,
    0,0,0,1,0),
  nrow = 6, ncol = 5, byrow = TRUE,
  dimnames = list(
    c("suceso1","suceso2","suceso3","suceso4","suceso5","suceso6"),
    c("Pan","Agua","Cafe","Leche","Naranja")
  ),
  sparse = TRUE
)

# --- Conversión a matriz lógica y transposición ---
muestrangCMatrix <- as(muestra, "nsparseMatrix")
traspmuestrangCMatrix <- t(muestrangCMatrix)

# --- Conversión final al formato transactions ---
transacciones <- as(traspmuestrangCMatrix, "transactions")

# --- Resumen de las transacciones ---
summary(transacciones)

# --- Aplicación del algoritmo Apriori ---
asociaciones <- apriori(
  transacciones,
  parameter = list(
    support = 0.5,       # soporte mínimo 50%
    confidence = 0.8     # confianza mínima 80%
  )
)

# --- Visualización de las reglas generadas ---
inspect(asociaciones)




# ==============================================================================
# EJERCICIO 1.4: DETECCIÓN DE OUTLIERS (K-VECINOS Y LOF)
# ==============================================================================

# --------------------------------------------------------------------------
# FASE 1: K-VECINOS
# --------------------------------------------------------------------------

# En primer lugar metemos los datos
(muestra<-matrix(c(4,4,4,3,5,5,1,1,5,4),2,5))

# Luego hacemos:
(muestra<-t(muestra))

# Calculamos las distancias con la función dist (distancias euclídeas) 
# y las metemos en una matriz
(distancias=as.matrix(dist(muestra)))

# Y definimos las distancias como una matriz 5x5
(distancias=matrix(distancias,5,5))

# Cogemos 3 k-vecinos para buscar los outliers, pero como cuenta cada punto consigo mismo,
# debemos buscar la 4 distancia. Cogemos las columnas y las ordenamos.
for(i in 1:5) {distancias[,i]=sort(distancias[,i])}; (distanciasord=distancias)

# Ahora buscamos aquellos k-3 vecinos que estén a una distancia mayor de aquella que definimos
# para encontrar los outliers, es decir, la columna cuya 4ª fila sea mayor a la distancia dada,
# es un outlier.
for (i in 1:5) {if (distanciasord[4,i]>2.5) {print(i); print("es un outlier")}}

# --------------------------------------------------------------------------
# FASE 2: LOF
# --------------------------------------------------------------------------

# Se instala el paquete Rlof
install.packages("Rlof")

library(Rlof)

# Se define la matriz de datos con 5 observaciones y 2 variables
# Las variables representan calificaciones en Teoría y Laboratorio de 5 estudiantes
muestra <- matrix(c(4,4,
                    4,3,
                    5,5,
                    1,1,
                    5,4), 
                  byrow = TRUE, ncol = 2)

# Se asignan nombres a las columnas y filas
colnames(muestra) <- c("Teoria","Laboratorio")
rownames(muestra) <- 1:5

# Se imprime la matriz de datos
print("Matriz de datos:")
print(muestra)

# Se elige el valor de k (número de vecinos)
k <- 3

# Se aplica la función lof() del paquete Rlof
lof_scores <- Rlof::lof(muestra, k = k, method = "manhattan")

# Se muestran los valores LOF redondeados a 3 decimales
print(paste("Valores LOF para k =", k, ":"))
print(round(lof_scores, 3))

# Se establece un umbral para identificar outliers
umbral <- 1.5

# Se identifican los índices de las observaciones que superan el umbral
outliers <- which(lof_scores > umbral)

# Se muestran los resultados
if (length(outliers) == 0) {
  cat("\nNo se detectaron outliers (LOF <", umbral, ")\n")
} else {
  cat("\nObservaciones detectadas como outliers (LOF >", umbral, "):\n")
  print(outliers)
  print("Coordenadas de los outliers:")
  print(muestra[outliers, ])
}


# ==============================================================================
# EJERCICIO 2.1: ANÁLISIS DESCRIPTIVO MANUAL
# ==============================================================================

# ============================
# Definición de funciones 
# ============================

# Función para contar filas 
contar_filas <- function(vec) {
  # Se inicializa el contador
  n <- 0
  # Se itera elemento a elemento y se incrementa el contador
  for (._ in vec) n <- n + 1
  # Se retorna el total contado
  n
}

# Función para contar columnas 
contar_columnas <- function(df) {
  # Se inicializa el contador
  c <- 0
  # Se itera sobre los nombres de las columnas y se incrementa el contador
  for (._ in names(df)) c <- c + 1
  # Se retorna el total contado
  c
}

# Función para ordenar índices 
ordenar_indices <- function(x, decreasing = FALSE) {
  # Se cuenta manualmente el número de elementos
  n <- 0
  for (._ in x) n <- n + 1
  # Se crea un vector con los índices 1..n
  idx <- 1:n
  # Se aplica un algoritmo de ordenamiento (burbuja)
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      # Si el orden es ascendente se compara menor que, si es descendente mayor que
      if ((!decreasing && x[j] < x[i]) || (decreasing && x[j] > x[i])) {
        # Intercambiar elementos
        tmp <- x[i]; x[i] <- x[j]; x[j] <- tmp
        # Intercambiar índices
        tmp2 <- idx[i]; idx[i] <- idx[j]; idx[j] <- tmp2
      }
    }
  }
  # Se retornan los índices ordenados
  idx
}

# Función para calcular el rango 
rango_manual <- function(x) {
  # Inicializar máximo y mínimo con el primer valor
  maximo <- x[1]
  minimo <- x[1]
  # Iterar sobre los valores para encontrar máximo y mínimo
  for (valor in x) {
    # Si el valor es mayor que el máximo actual, actualizar máximo
    if (valor > maximo) maximo <- valor
    # Si el valor es menor que el mínimo actual, actualizar mínimo
    if (valor < minimo) minimo <- valor
  }
  # Retornar el rango
  maximo - minimo
}

# Función para obtener valores únicos
valores_unicos_manual <- function(x) {
  # En primer lugar, se crea un vector vacío para almacenar los valores únicos
  unicos <- c()
  # Se itera sobre cada valor
  for (v in x) {
    # Flag para indicar si el valor ya fue encontrado
    encontrado <- FALSE
    # Se verifica si el valor ya está en el vector de valores únicos
    for (u in unicos) {
      if (v == u) { encontrado <- TRUE; break }
    }
    # Si el valor no fue encontrado, se agrega al vector de valores únicos
    if (!encontrado) unicos <- c(unicos, v)
  }
  # Se ordenan los valores únicos y se retornan
  unicos[ordenar_indices(unicos)]
}

# Función para contar cuántos elementos hay en un vector (sin length)
contar_elementos <- function(x) {
  # Se inicializa el contador
  n <- 0
  # Se incrementa por cada elemento del vector
  for (._ in x) n <- n + 1
  # Se retorna el total
  n
}

# Función para calcular la frecuencia absoluta 
frecuencia_absoluta_manual <- function(x, valores_ordenados) {
  # Se obtiene el número de valores únicos
  k <- contar_elementos(valores_ordenados)
  # Inicializar el vector de frecuencias absolutas
  frec <- numeric(k)
  # Se itera sobre cada valor observado
  for (v in x) {
    # Se compara con cada valor único
    for (i in 1:k) {
      # Si coincide, se incrementa la frecuencia absoluta correspondiente
      if (v == valores_ordenados[i]) { frec[i] <- frec[i] + 1; break }
    }
  }
  # Se retorna el vector de frecuencias
  frec
}

# Función para calcular la frecuencia acumulada 
acumulada_manual <- function(vec) {
  # Se cuenta cuántos elementos tiene el vector
  n <- contar_elementos(vec)
  # Inicializar el vector de frecuencias acumuladas
  out <- numeric(n)
  # Se suman progresivamente las frecuencias
  acum <- 0
  for (i in 1:n) { acum <- acum + vec[i]; out[i] <- acum }
  # Se retorna la acumulada
  out
}

# Función para calcular la frecuencia relativa manual
relativa_manual <- function(frec_abs, total) {
  # Se cuenta el tamaño del vector de frecuencias absolutas
  n <- contar_elementos(frec_abs)
  # Inicializar el vector de frecuencias relativas
  out <- numeric(n)
  # Se calcula dividiendo la frecuencia absoluta entre el total de filas
  for (i in 1:n) out[i] <- frec_abs[i] / total
  # Se retorna la frecuencia relativa
  out
}

# Función para calcular la media 
media_manual <- function(x) {
  # Se incializa la suma a cero
  suma <- 0
  # Se cuenta el número de elementos
  n <- contar_elementos(x)
  # Se suma cada valor
  for (v in x) suma <- suma + v
  # Se retorna la media
  suma / n
}

# Función para calcular la varianza poblacional 
varianza_poblacional_manual <- function(x) {
  # Se cuenta el número de elementos
  n <- contar_elementos(x)
  # Se calcula la media manualmente
  m <- media_manual(x)
  # Se calcula la suma de los cuadrados de las diferencias respecto a la media
  suma_cuad <- 0
  for (v in x) suma_cuad <- suma_cuad + (v - m)^2
  # Varianza poblacional: dividir entre N
  suma_cuad / n
}

# Función para calcular la varianza muestral 
varianza_muestral_manual <- function(x) {
  # Se cuenta el número de elementos
  n <- contar_elementos(x)
  # Si no hay suficientes datos, se retorna NA
  if (n <= 1) return(NA_real_)
  # Se calcula la media manualmente
  m <- media_manual(x)
  # Se calcula la suma de los cuadrados de las diferencias respecto a la media
  suma_cuad <- 0
  for (v in x) suma_cuad <- suma_cuad + (v - m)^2
  # Varianza muestral: dividir entre (N - 1)
  suma_cuad / (n - 1)
}

# Función para obtener la desviación estándar a partir de una varianza
desv_estandar <- function(varianza) {
  # Si la varianza es NA, se retorna NA
  if (is.na(varianza)) return(NA_real_)
  # Se calcula la raíz cuadrada de la varianza
  sqrt(varianza)
}

# ============================
# Script principal 
# ============================

# Se lee el archivo de datos y se indica que la primera fila contiene los nombres de las columnas
s <- read.table("distancias.txt", header = TRUE)
# Mostrar el data frame
print(s)

# Contar filas manualmente
# Se inicializa el contador de filas mediante función
filas <- contar_filas(s$distancia)

# Contar columnas manualmente
# Se inicializa el contador de columnas mediante función
columnas <- contar_columnas(s)

# Mostrar dimensiones
cat("Dimensiones (filas x columnas): ", filas, " x ", columnas, "\n", sep = "")

# Se obtienen los índices ordenados ascendente y descendentemente
idx_asc  <- ordenar_indices(s$distancia)
idx_desc <- ordenar_indices(s$distancia, decreasing = TRUE)

# Se crean los data frames ordenados
so_asc  <- s[idx_asc, ]
so_desc <- s[idx_desc, ]

# Mostrar los data frames ordenados
cat("Orden ascendente por distancia:\n")
print(so_asc)
cat("\nOrden descendente por distancia:\n")
print(so_desc)
cat("\n")

# Se calcula el rango de la columna 'distancia'
rangor <- rango_manual(s$distancia)
# Se muestra el rango
cat("Rango (max - min) de distancia:", rangor, "\n\n")

# Obtener valores únicos 
valores_unicos <- valores_unicos_manual(s$distancia)

# Contar cuántos valores únicos hay
n_valores <- contar_elementos(valores_unicos)

# Se calcula la frecuencia absoluta
frecuencia_abs <- frecuencia_absoluta_manual(s$distancia, valores_unicos)

# Mostrar frecuencia absoluta
cat("Frecuencia absoluta:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_abs[i], "\n")
cat("\n")

# Calcular frecuencia acumulada
frecuencia_acum <- acumulada_manual(frecuencia_abs)

# Mostrar frecuencia acumulada
cat("Frecuencia acumulada:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_acum[i], "\n")
cat("\n")

# Calcular la frecuencia relativa y frecuencia relativa acumulada
# Frecuencia relativa (frecuencia absoluta / total de filas)
frecuencia_rel <- relativa_manual(frecuencia_abs, filas)

# Frecuencia relativa acumulada 
frecuencia_rel_acum <- acumulada_manual(frecuencia_rel)

# Mostrar frecuencia relativa
cat("Frecuencia relativa:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_rel[i], "\n")
cat("\n")

# Mostrar frecuencia relativa acumulada
cat("Frecuencia relativa acumulada:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_rel_acum[i], "\n")
cat("\n")

# Calcular media
# Se calcula la media de 'distancia' usando la función manual
media <- media_manual(s$distancia)
# Mostrar la media
cat("Media:", media, "\n")

# Varianza muestral y poblacional
# Se calcula la varianza poblacional manual
varianza_poblacional <- varianza_poblacional_manual(s$distancia)
# Se calcula la varianza muestral manual
varianza_muestral <- varianza_muestral_manual(s$distancia)
# Se calcula la desviación estándar poblacional como raíz de la varianza poblacional
desv_est_poblacional <- desv_estandar(varianza_poblacional)
# Se calcula la desviación estándar muestral como raíz de la varianza muestral
desv_est_muestral <- desv_estandar(varianza_muestral)

# Mostrar varianzas y desviaciones estándar
cat("Varianza poblacional:", varianza_poblacional, "\n")
cat("Desviación estándar poblacional:", desv_est_poblacional, "\n")
cat("Varianza muestral:", varianza_muestral, "\n")
cat("Desviación estándar muestral:", desv_est_muestral, "\n")


# ==============================================================================
# EJERCICIO 1.2: Análisis de asociación.
# ==============================================================================

# --- Carga del paquete arules (instalar si es necesario) ---
# install.packages("arules")  # Descomentar si no está instalado
library(arules)

# --- Creación de la matriz binaria de cestas de compra ---
muestra <- Matrix(
  c(1,1,0,1,1,
    1,1,1,1,0,
    1,1,0,1,0,
    1,0,1,1,0,
    1,1,0,0,0,
    0,0,0,1,0),
  nrow = 6, ncol = 5, byrow = TRUE,
  dimnames = list(
    c("suceso1","suceso2","suceso3","suceso4","suceso5","suceso6"),
    c("Pan","Agua","Cafe","Leche","Naranja")
  ),
  sparse = TRUE
)

# --- Conversión a matriz lógica y transposición ---
muestrangCMatrix <- as(muestra, "nsparseMatrix")
traspmuestrangCMatrix <- t(muestrangCMatrix)

# --- Conversión final al formato transactions ---
transacciones <- as(traspmuestrangCMatrix, "transactions")

# --- Resumen de las transacciones ---
summary(transacciones)

# --- Aplicación del algoritmo Apriori ---
asociaciones <- apriori(
  transacciones,
  parameter = list(
    support = 0.5,       # soporte mínimo 50%
    confidence = 0.8     # confianza mínima 80%
  )
)

# --- Visualización de las reglas generadas ---
inspect(asociaciones)



# ==============================================================================
# EJERCICIO 2.3: Análisis de detección de datos anómalos utilizando técnicas con base estadística.
# ==============================================================================

# CREACIÓN DEL CONJUNTO DE DATOS.
# Se crea un data frame con dos variables: Velocidad y Temperatura
# Cada fila representa una observación independiente
datos <- data.frame(
  Velocidad = c(10,8,13,9,11,14,6,4,12,7,5),
  Temperatura = c(7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73)
)

# FUNCIONES AUXILIARES BÁSICAS.

# Contar elementos manualmente
contar_elementos <- function(x) {
  n <- 0
  for (._ in x) n <- n + 1 # Incrementa n por cada elemento
  n
}

# Suma manual
mi_suma <- function(x) {
  total <- 0
  for (valor in x) total <- total + valor # Suma acumulativa de los valores
  total
}

# Media manual
media_manual <- function(x) {
  suma <- mi_suma(x)
  n <- contar_elementos(x)
  suma / n
}

# Varianza manual
varianza_manual <- function(x) {
  n <- contar_elementos(x)     # Número de elementos
  media <- media_manual(x)     # Media del vector
  suma <- 0
  for (v in x) suma <- suma + (v - media)^2   # Suma de desviaciones al cuadrado
  suma / n                   # Varianza = suma de cuadrados / n
}

# Desviación típica manual
desviacion_manual <- function(x) {
  sqrt(varianza_manual(x))
}


#FUNCIONES PARA CADA MÉTODO.


# Método IQR manual

detectar_outliers_iqr <- function(x) {
  resumen <- fivenum(x)      # Calcula los cinco números resumen: min, Q1, mediana, Q3, max
  Q1 <- resumen[2]           # Primer cuartil
  Q3 <- resumen[4]           # Tercer cuartil
  IQRv <- Q3 - Q1            # Rango intercuartílico
  lim_inf <- Q1 - 1.5 * IQRv # Límite inferior para detectar outliers
  lim_sup <- Q3 + 1.5 * IQRv # Límite superior para detectar outliers
  
  cat("\n--- DETECCIÓN OUTLIERS IQR ---\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  
  i <- 1
  hay_outliers <- FALSE
  for (v in x) {
    if (v < lim_inf || v > lim_sup) { # Si el valor está fuera de los límites
      cat("Índice:", i, "→ Valor =", v, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}


# Método de la desviación típica manual

detectar_outliers_sd <- function(x, d = 2) {
  media <- media_manual(x)
  desv <- desviacion_manual(x)
  lim_inf <- media - d * desv
  lim_sup <- media + d * desv
  
  cat("\n--- DETECCIÓN OUTLIERS DESVIACIÓN TÍPICA ---\n")
  cat("Media:", media, "\n")
  cat("Desviación típica:", desv, "\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  
  i <- 1
  hay_outliers <- FALSE
  for (valor in x) {
    if (valor < lim_inf || valor > lim_sup) {
      cat("Índice:", i, "→ Valor =", valor, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}


# Método de regresión manual con detección por residuos

detectar_outliers_regresion <- function(x, y, d = 2) {
  n <- contar_elementos(x)  # Número de observaciones
  media_x <- media_manual(x)
  media_y <- media_manual(y)
  
  # Calcular los coeficientes de la recta de regresión y = b0 + b1*x
  num <- 0
  den <- 0
  for (i in seq(n)) {
    num <- num + (x[i] - media_x) * (y[i] - media_y)
    den <- den + (x[i] - media_x)^2
  }
  b1 <- num / den # Pendiente
  b0 <- media_y - b1 * media_x
  
  # Calcular residuos (diferencia entre y observado y y estimado)
  residuos <- numeric(n)
  for (i in seq(n)) {
    y_est <- b0 + b1 * x[i]
    residuos[i] <- y[i] - y_est
  }
  
  # Calcular error estándar de residuos
  suma_res <- 0
  for (r in residuos) suma_res <- suma_res + r^2
  error_est <- sqrt(suma_res / n)
  
  cat("\n--- DETECCIÓN OUTLIERS REGRESIÓN ---\n")
  cat("Ecuación: y =", round(b0, 4), "+", round(b1, 4), "* x\n")
  cat("Error estándar de residuos:", round(error_est, 4), "\n")
  
  i <- 1
  hay_outliers <- FALSE
  for (r in residuos) {
    if (abs(r) > d * error_est) { # Si el residuo supera d veces el error estándar
      cat("Índice:", i, "→ Residuo =", round(r, 4), "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers en los residuos.\n")
}

# APLICACIÓN DE LOS MÉTODOS

detectar_outliers_iqr(datos$Velocidad)
detectar_outliers_sd(datos$Temperatura)
detectar_outliers_regresion(datos$Velocidad, datos$Temperatura)


# ==============================================================================
# EJERCICIO 2.4: DETECCIÓN DE OUTLIERS MANUAL (K-NN y LOF)
# ==============================================================================

# --- 0. Carga de Datos ---
# Se asume que 'seminarios.txt' está en el directorio de trabajo.

if (!exists("s_bio")) {
  s_bio <- read.table("seminarios.txt", header = TRUE)
}

cat(">> Conjunto de datos (Asistencia):\n")
print(s_bio)

# Preparación común
datos_m <- as.matrix(s_bio)
n <- nrow(datos_m)

# ==============================================================================
# PARTE 1: K-NN MANUAL (Proximidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 1: K-NN MANUAL (Proximidad)\n")
cat("********************************************************************\n")

# Parámetros
K_knn <- 3
UMBRAL_DIST_KNN <- 5

# --- Paso 1: Cálculo Manual Matriz Distancias (Euclídea) ---
cat("\n[Paso 1] Matriz de Distancias Euclídeas:\n")
matriz_dist_euclidea <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = sqrt( (x1-x2)^2 + (y1-y2)^2 )
    matriz_dist_euclidea[i, j] <- sqrt((datos_m[i,1] - datos_m[j,1])^2 + 
                                       (datos_m[i,2] - datos_m[j,2])^2)
  }
}
print(round(matriz_dist_euclidea, 2))

# --- Paso 2: Análisis de Vecinos y Detección ---
cat("\n[Paso 2 & 3] Análisis de Vecindad (K =", K_knn, ") y Detección:\n")

for (i in 1:n) {
  dists_punto <- matriz_dist_euclidea[i, ]
  orden_vecinos <- order(dists_punto)
  
  # Los vecinos reales empiezan en el índice 2 (el 1 es el propio punto)
  indices_k_vecinos <- orden_vecinos[2:(K_knn + 1)]
  dist_k_esimo <- dists_punto[orden_vecinos[K_knn + 1]]
  
  # Mostrar detalle de los vecinos
  cat("\n--- Analizando Punto P", i, " ---\n", sep="")
  # Desglose de los 3 vecinos más cercanos
  for (k in 1:K_knn) {
     vecino_idx <- orden_vecinos[k+1]
     cat("   ", k, "º Vecino más cercano: P", vecino_idx, 
         " (Distancia: ", round(dists_punto[vecino_idx], 2), ")\n", sep="")
  }
  
  # Decisión final para el punto
  es_outlier <- dist_k_esimo > UMBRAL_DIST_KNN
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER!" else "-> Normal"
  
  cat(">> CONCLUSIÓN P", i, ": Distancia al 3er vecino = ", 
      round(dist_k_esimo, 2), " ", estado, "\n", sep="")
}


# ==============================================================================
# PARTE 2: LOF MANUAL (Densidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 2: LOF MANUAL (Densidad)\n")
cat("********************************************************************\n")

# Parámetros
K_lof <- 3
UMBRAL_DRM <- 0.8

# --- Paso Previo: Matriz Distancias Manhattan  ---
cat("\n[Paso Previo] Recálculo con Distancia Manhattan (para LOF):\n")
matriz_dist_manhattan <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = |x1-x2| + |y1-y2|
    matriz_dist_manhattan[i, j] <- abs(datos_m[i,1] - datos_m[j,1]) + 
                                   abs(datos_m[i,2] - datos_m[j,2])
  }
}
print(matriz_dist_manhattan)

# --- FASE A: Cálculo de Densidades Locales ---
cat("\n[FASE A] Cálculo de Densidad Local (d) para cada punto:\n")
cat("Fórmula: d(Pi) = ( Suma_distancias_a_K_vecinos / K )^-1\n\n")

densidad_local <- numeric(n)
vecinos_indices_lista <- vector("list", n) # Necesario para Fase B

for (i in 1:n) {
  dists <- matriz_dist_manhattan[i, ]
  orden <- order(dists)
  
  # Identificar los K vecinos
  mis_vecinos_idx <- orden[2:(K_lof + 1)]
  vecinos_indices_lista[[i]] <- mis_vecinos_idx
  
  # Suma de distancias
  suma_dist <- sum(dists[mis_vecinos_idx])
  
  # Cálculo de densidad
  densidad_local[i] <- (suma_dist / K_lof)^-1
  
  # Salida detallada
  vecinos_str <- paste("P", mis_vecinos_idx, sep="", collapse=", ")
  cat("P", i, ": Vecinos {", vecinos_str, "} | Suma Distancias: ", suma_dist,
      " | Densidad d(P", i, "): ", round(densidad_local[i], 4), "\n", sep="")
}

# --- FASE B: Cálculo de Densidad Relativa Media (drm) ---
cat("\n[FASE B] Cálculo de Densidad Relativa Media (drm):\n")
cat("Fórmula: drm(Pi) = d(Pi) / Media( d(vecinos_de_Pi) )\n\n")

drm_scores <- numeric(n)

for (i in 1:n) {
  # 1. Densidad propia
  mi_densidad <- densidad_local[i]
  
  # 2. Densidades de mis vecinos (recuperadas de la lista guardada en Fase A)
  indices_mis_vecinos <- vecinos_indices_lista[[i]]
  densidades_vecinos <- densidad_local[indices_mis_vecinos]
  
  # 3. Media de las densidades de los vecinos
  media_dens_vecinos <- mean(densidades_vecinos)
  
  # 4. Cálculo del drm
  drm_scores[i] <- mi_densidad / media_dens_vecinos
  
  # Salida detallada mostrando la comparación
  cat("P", i, " -> Mi Densidad: ", round(mi_densidad, 3), 
      " | Media Dens. Vecinos (P", paste(indices_mis_vecinos, collapse=",P"), 
      "): ", round(media_dens_vecinos, 3), 
      " | drm: ", round(drm_scores[i], 4), "\n", sep="")
}

# --- FASE C: Detección Final ---
cat("\n[FASE C] Resultados Finales LOF (Umbral drm <", UMBRAL_DRM, "):\n", sep="")

for (i in 1:n) {
  es_outlier <- drm_scores[i] < UMBRAL_DRM
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER! (Densidad relativa muy baja)" else "-> Normal"
  cat(sprintf("Punto P%d | drm = %.4f \t%s\n", i, drm_scores[i], estado))
}

cat("\n********************************************************************\n")
cat(" FIN DEL ANÁLISIS MANUAL EJERCICIO 2.4\n")
cat("********************************************************************\n")
