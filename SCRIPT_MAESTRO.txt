# ==============================================================================
# MASTER SCRIPT: FUNDAMENTOS DE CIENCIA DE DATOS (PL1)
# ==============================================================================

# ==============================================================================
# EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO GUIADO (Satélites de Urano)
# Usa funciones estándar de R base.
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO (SATÉLITES URANO)\n")
cat("********************************************************************\n")

# --- 1. Carga de datos ---
# Asegúrate de tener 'satelites.txt' en tu directorio de trabajo (setwd)
# Contenido esperado de satelites.txt:
# nombre radio
# Cordelia 13
# Ofelia 16
# ...
s <- read.table("satelites.txt", header = TRUE)
print(">> Conjunto de datos original:")
print(s)

# --- 2. Ordenación ---
# Orden ascendente por radio
so_asc <- s[order(s$radio), ]
print(">> Datos ordenados (ascendente) por Radio:")
print(so_asc)

# Orden descendente por radio
so_desc <- s[rev(order(s$radio)), ]
print(">> Datos ordenados (descendente) por Radio:")
print(so_desc)

# --- 3. Medidas de Dispersión Básicas (Rango) ---
rango_val <- max(s$radio) - min(s$radio)
cat("\n>> Rango del radio:", rango_val, "km\n")

# --- 4. Tablas de Frecuencias ---
frec_abs <- table(s$radio)                # Frecuencia absoluta
frec_abs_acum <- cumsum(frec_abs)         # Frecuencia absoluta acumulada
frec_rel <- frec_abs / length(s$radio)    # Frecuencia relativa
frec_rel_acum <- cumsum(frec_rel)         # Frecuencia relativa acumulada

# Visualización compacta en data frame
tabla_frec <- data.frame(
  Radio = names(frec_abs),
  ni = as.integer(frec_abs),
  Ni = as.integer(frec_abs_acum),
  fi = round(as.numeric(frec_rel), 3),
  Fi = round(as.numeric(frec_rel_acum), 3)
)
cat("\n>> Tabla de Frecuencias Completa (Radio):\n")
print(tabla_frec)

# --- 5. Medidas de Tendencia Central ---
media_r <- mean(s$radio)
mediana_r <- median(s$radio)

cat("\n>> Medidas de Tendencia Central:\n")
cat("   Media:", round(media_r, 2), "km\n")
cat("   Mediana:", mediana_r, "km\n")

# --- 6. Medidas de Dispersión y Posición ---
# Nota: var() y sd() en R calculan la versión muestral (n-1)
var_r <- var(s$radio)
sd_r <- sd(s$radio)
# Cuartiles (25%, 50%, 75%)
cuartiles <- quantile(s$radio, probs = c(0.25, 0.50, 0.75))

cat("\n>> Medidas de Dispersión y Posición:\n")
cat("   Varianza (muestral):", round(var_r, 2), "\n")
cat("   Desviación Típica (muestral):", round(sd_r, 2), "km\n")
cat("   Cuartiles:\n")
print(cuartiles)




# ==============================================================================
# EJERCICIO 1.2: Análisis de asociación.
# ==============================================================================

# --- Carga del paquete arules (instalar si es necesario) ---
# install.packages("arules")  # Descomentar si no está instalado
library(arules)

# --- Creación de la matriz binaria de cestas de compra ---
muestra <- Matrix(
  c(1,1,0,1,1,
    1,1,1,1,0,
    1,1,0,1,0,
    1,0,1,1,0,
    1,1,0,0,0,
    0,0,0,1,0),
  nrow = 6, ncol = 5, byrow = TRUE,
  dimnames = list(
    c("suceso1","suceso2","suceso3","suceso4","suceso5","suceso6"),
    c("Pan","Agua","Cafe","Leche","Naranja")
  ),
  sparse = TRUE
)

# --- Conversión a matriz lógica y transposición ---
muestrangCMatrix <- as(muestra, "nsparseMatrix")
traspmuestrangCMatrix <- t(muestrangCMatrix)

# --- Conversión final al formato transactions ---
transacciones <- as(traspmuestrangCMatrix, "transactions")

# --- Resumen de las transacciones ---
summary(transacciones)

# --- Aplicación del algoritmo Apriori ---
asociaciones <- apriori(
  transacciones,
  parameter = list(
    support = 0.5,       # soporte mínimo 50%
    confidence = 0.8     # confianza mínima 80%
  )
)

# --- Visualización de las reglas generadas ---
inspect(asociaciones)

# ==============================================================================
# EJERCICIO 1.3: DETECCIÓN DE OUTLIERS (CAJA Y BIGOTES, DESVIACIÓN TÍPICA, REGRESIÓN)
# ==============================================================================

# --------------------------------------------------------------------------
# CAJA Y BIGOTES
# --------------------------------------------------------------------------

#Introducimos los datos de la muestra en una matriz
(muestra<-t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r", "d")))))

#Se convierte la matriz en un data frame
(muestra<-data.frame(muestra))

#Devuelve los outliers de la columna resistencia usando el range
(boxplot(muestra$r, range=1.5, plot=FALSE))

#Si no se quiere emplear la función boxplot, se pueden realizar los cálculos manualmente
#Se calcula el cuartil primero
(cuar1r<-quantile(muestra$r, 0.25))

#Se calcula el cuartil tercero
(cuar3r<-quantile(muestra$r, 0.75))

#Se obtiene una tupla de indices que muestra los límites inferiores y superiores
(int<-c(cuar1r-1.5*(cuar3r-cuar1r), cuar3r+1.5*(cuar3r-cuar1r)))

#Se observa que valores de la columna resistencia están fuera de los límites cálculados
for (i in 1:length(muestra$r))
{if (muestra$r[i]<int[1] || muestra$r[i]>int[2])
{print("el suceso"); print(i); print(muestra$r[i]); print("es un outlier")}}

# --------------------------------------------------------------------------
# DESVIACIÓN TÍPICA
# --------------------------------------------------------------------------

#Se obtiene el valor de sdd, valor que será multiplicado por el grado de outlier para definir los límites
sdd<-sqrt(var(muestra$d)*((length(muestra$d)-1)/length(muestra$d)))

#Se obtiene una tupla de indices que muestra los límites inferiores y superiores
(intdes<-c(mean(muestra$d)-2*sdd, mean(muestra$d)+2*sdd))

#Se observa que valores de la columna densidad están fuera de los límites cálculados
for (i in 1:length(muestra$d))
{if (muestra$d[i]<intdes[1] ||  muestra$d[i]>intdes[2])
{print("el suceso"); print(i); print(muestra$d[i]); print("es un outlier")}}

# --------------------------------------------------------------------------
# REGRESIÓN
# --------------------------------------------------------------------------
#Se ajusta un modelo lineal
(dfr<-lm(muestra$d~muestra$r))

#Se muestra un resumen con elementos estadísticos de dicho modelo lineal
(summary(dfr))

#Se obtienes los valores predichos 
(res<-summary(dfr)$residuals)

#Se obtiene el error estandar de los residuos
sr<-sqrt(sum(res^2)/length(res))

#Se imprime el valor del error estandar de los residuos
sr

Se itera sobre todos los valores predichos para ver cuales superan el límite de d*sr 
for (i in 1:length(res))
{if (res[i]>2*sr)
{print("el suceso"); print(res[i]); print("es un outlier")}}

# ==============================================================================
# EJERCICIO 1.4: DETECCIÓN DE OUTLIERS (K-VECINOS Y LOF)
# ==============================================================================

# --------------------------------------------------------------------------
# FASE 1: K-VECINOS
# --------------------------------------------------------------------------

# En primer lugar metemos los datos
(muestra<-matrix(c(4,4,4,3,5,5,1,1,5,4),2,5))

# Luego hacemos:
(muestra<-t(muestra))

# Calculamos las distancias con la función dist (distancias euclídeas) 
# y las metemos en una matriz
(distancias=as.matrix(dist(muestra)))

# Y definimos las distancias como una matriz 5x5
(distancias=matrix(distancias,5,5))

# Cogemos 3 k-vecinos para buscar los outliers, pero como cuenta cada punto consigo mismo,
# debemos buscar la 4 distancia. Cogemos las columnas y las ordenamos.
for(i in 1:5) {distancias[,i]=sort(distancias[,i])}; (distanciasord=distancias)

# Ahora buscamos aquellos k-3 vecinos que estén a una distancia mayor de aquella que definimos
# para encontrar los outliers, es decir, la columna cuya 4ª fila sea mayor a la distancia dada,
# es un outlier.
for (i in 1:5) {if (distanciasord[4,i]>2.5) {print(i); print("es un outlier")}}

# --------------------------------------------------------------------------
# FASE 2: LOF
# --------------------------------------------------------------------------

# Se instala el paquete Rlof
install.packages("Rlof")

library(Rlof)

# Se define la matriz de datos con 5 observaciones y 2 variables
# Las variables representan calificaciones en Teoría y Laboratorio de 5 estudiantes
muestra <- matrix(c(4,4,
                    4,3,
                    5,5,
                    1,1,
                    5,4), 
                  byrow = TRUE, ncol = 2)

# Se asignan nombres a las columnas y filas
colnames(muestra) <- c("Teoria","Laboratorio")
rownames(muestra) <- 1:5

# Se imprime la matriz de datos
print("Matriz de datos:")
print(muestra)

# Se elige el valor de k (número de vecinos)
k <- 3

# Se aplica la función lof() del paquete Rlof
lof_scores <- Rlof::lof(muestra, k = k, method = "manhattan")

# Se muestran los valores LOF redondeados a 3 decimales
print(paste("Valores LOF para k =", k, ":"))
print(round(lof_scores, 3))

# Se establece un umbral para identificar outliers
umbral <- 1.5

# Se identifican los índices de las observaciones que superan el umbral
outliers <- which(lof_scores > umbral)

# Se muestran los resultados
if (length(outliers) == 0) {
  cat("\nNo se detectaron outliers (LOF <", umbral, ")\n")
} else {
  cat("\nObservaciones detectadas como outliers (LOF >", umbral, "):\n")
  print(outliers)
  print("Coordenadas de los outliers:")
  print(muestra[outliers, ])
}


# ==============================================================================
# EJERCICIO 2.1: ANÁLISIS DESCRIPTIVO MANUAL
# ==============================================================================

# ============================
# Definición de funciones 
# ============================

# Función para contar filas 
contar_filas <- function(vec) {
  # Se inicializa el contador
  n <- 0
  # Se itera elemento a elemento y se incrementa el contador
  for (._ in vec) n <- n + 1
  # Se retorna el total contado
  n
}

# Función para contar columnas 
contar_columnas <- function(df) {
  # Se inicializa el contador
  c <- 0
  # Se itera sobre los nombres de las columnas y se incrementa el contador
  for (._ in names(df)) c <- c + 1
  # Se retorna el total contado
  c
}

# Función para ordenar índices 
ordenar_indices <- function(x, decreasing = FALSE) {
  # Se cuenta manualmente el número de elementos
  n <- 0
  for (._ in x) n <- n + 1
  # Se crea un vector con los índices 1..n
  idx <- 1:n
  # Se aplica un algoritmo de ordenamiento (burbuja)
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      # Si el orden es ascendente se compara menor que, si es descendente mayor que
      if ((!decreasing && x[j] < x[i]) || (decreasing && x[j] > x[i])) {
        # Intercambiar elementos
        tmp <- x[i]; x[i] <- x[j]; x[j] <- tmp
        # Intercambiar índices
        tmp2 <- idx[i]; idx[i] <- idx[j]; idx[j] <- tmp2
      }
    }
  }
  # Se retornan los índices ordenados
  idx
}

# Función para calcular el rango 
rango_manual <- function(x) {
  # Inicializar máximo y mínimo con el primer valor
  maximo <- x[1]
  minimo <- x[1]
  # Iterar sobre los valores para encontrar máximo y mínimo
  for (valor in x) {
    # Si el valor es mayor que el máximo actual, actualizar máximo
    if (valor > maximo) maximo <- valor
    # Si el valor es menor que el mínimo actual, actualizar mínimo
    if (valor < minimo) minimo <- valor
  }
  # Retornar el rango
  maximo - minimo
}

# Función para obtener valores únicos
valores_unicos_manual <- function(x) {
  # En primer lugar, se crea un vector vacío para almacenar los valores únicos
  unicos <- c()
  # Se itera sobre cada valor
  for (v in x) {
    # Flag para indicar si el valor ya fue encontrado
    encontrado <- FALSE
    # Se verifica si el valor ya está en el vector de valores únicos
    for (u in unicos) {
      if (v == u) { encontrado <- TRUE; break }
    }
    # Si el valor no fue encontrado, se agrega al vector de valores únicos
    if (!encontrado) unicos <- c(unicos, v)
  }
  # Se ordenan los valores únicos y se retornan
  unicos[ordenar_indices(unicos)]
}

# Función para contar cuántos elementos hay en un vector (sin length)
contar_elementos <- function(x) {
  # Se inicializa el contador
  n <- 0
  # Se incrementa por cada elemento del vector
  for (._ in x) n <- n + 1
  # Se retorna el total
  n
}

# Función para calcular la frecuencia absoluta 
frecuencia_absoluta_manual <- function(x, valores_ordenados) {
  # Se obtiene el número de valores únicos
  k <- contar_elementos(valores_ordenados)
  # Inicializar el vector de frecuencias absolutas
  frec <- numeric(k)
  # Se itera sobre cada valor observado
  for (v in x) {
    # Se compara con cada valor único
    for (i in 1:k) {
      # Si coincide, se incrementa la frecuencia absoluta correspondiente
      if (v == valores_ordenados[i]) { frec[i] <- frec[i] + 1; break }
    }
  }
  # Se retorna el vector de frecuencias
  frec
}

# Función para calcular la frecuencia acumulada 
acumulada_manual <- function(vec) {
  # Se cuenta cuántos elementos tiene el vector
  n <- contar_elementos(vec)
  # Inicializar el vector de frecuencias acumuladas
  out <- numeric(n)
  # Se suman progresivamente las frecuencias
  acum <- 0
  for (i in 1:n) { acum <- acum + vec[i]; out[i] <- acum }
  # Se retorna la acumulada
  out
}

# Función para calcular la frecuencia relativa manual
relativa_manual <- function(frec_abs, total) {
  # Se cuenta el tamaño del vector de frecuencias absolutas
  n <- contar_elementos(frec_abs)
  # Inicializar el vector de frecuencias relativas
  out <- numeric(n)
  # Se calcula dividiendo la frecuencia absoluta entre el total de filas
  for (i in 1:n) out[i] <- frec_abs[i] / total
  # Se retorna la frecuencia relativa
  out
}

# Función para calcular la media 
media_manual <- function(x) {
  # Se incializa la suma a cero
  suma <- 0
  # Se cuenta el número de elementos
  n <- contar_elementos(x)
  # Se suma cada valor
  for (v in x) suma <- suma + v
  # Se retorna la media
  suma / n
}

# Función para calcular la varianza poblacional 
varianza_poblacional_manual <- function(x) {
  # Se cuenta el número de elementos
  n <- contar_elementos(x)
  # Se calcula la media manualmente
  m <- media_manual(x)
  # Se calcula la suma de los cuadrados de las diferencias respecto a la media
  suma_cuad <- 0
  for (v in x) suma_cuad <- suma_cuad + (v - m)^2
  # Varianza poblacional: dividir entre N
  suma_cuad / n
}

# Función para calcular la varianza muestral 
varianza_muestral_manual <- function(x) {
  # Se cuenta el número de elementos
  n <- contar_elementos(x)
  # Si no hay suficientes datos, se retorna NA
  if (n <= 1) return(NA_real_)
  # Se calcula la media manualmente
  m <- media_manual(x)
  # Se calcula la suma de los cuadrados de las diferencias respecto a la media
  suma_cuad <- 0
  for (v in x) suma_cuad <- suma_cuad + (v - m)^2
  # Varianza muestral: dividir entre (N - 1)
  suma_cuad / (n - 1)
}

# Función para obtener la desviación estándar a partir de una varianza
desv_estandar <- function(varianza) {
  # Si la varianza es NA, se retorna NA
  if (is.na(varianza)) return(NA_real_)
  # Se calcula la raíz cuadrada de la varianza
  sqrt(varianza)
}

# ============================
# Script principal 
# ============================

# Se lee el archivo de datos y se indica que la primera fila contiene los nombres de las columnas
s <- read.table("distancias.txt", header = TRUE)
# Mostrar el data frame
print(s)

# Contar filas manualmente
# Se inicializa el contador de filas mediante función
filas <- contar_filas(s$distancia)

# Contar columnas manualmente
# Se inicializa el contador de columnas mediante función
columnas <- contar_columnas(s)

# Mostrar dimensiones
cat("Dimensiones (filas x columnas): ", filas, " x ", columnas, "\n", sep = "")

# Se obtienen los índices ordenados ascendente y descendentemente
idx_asc  <- ordenar_indices(s$distancia)
idx_desc <- ordenar_indices(s$distancia, decreasing = TRUE)

# Se crean los data frames ordenados
so_asc  <- s[idx_asc, ]
so_desc <- s[idx_desc, ]

# Mostrar los data frames ordenados
cat("Orden ascendente por distancia:\n")
print(so_asc)
cat("\nOrden descendente por distancia:\n")
print(so_desc)
cat("\n")

# Se calcula el rango de la columna 'distancia'
rangor <- rango_manual(s$distancia)
# Se muestra el rango
cat("Rango (max - min) de distancia:", rangor, "\n\n")

# Obtener valores únicos 
valores_unicos <- valores_unicos_manual(s$distancia)

# Contar cuántos valores únicos hay
n_valores <- contar_elementos(valores_unicos)

# Se calcula la frecuencia absoluta
frecuencia_abs <- frecuencia_absoluta_manual(s$distancia, valores_unicos)

# Mostrar frecuencia absoluta
cat("Frecuencia absoluta:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_abs[i], "\n")
cat("\n")

# Calcular frecuencia acumulada
frecuencia_acum <- acumulada_manual(frecuencia_abs)

# Mostrar frecuencia acumulada
cat("Frecuencia acumulada:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_acum[i], "\n")
cat("\n")

# Calcular la frecuencia relativa y frecuencia relativa acumulada
# Frecuencia relativa (frecuencia absoluta / total de filas)
frecuencia_rel <- relativa_manual(frecuencia_abs, filas)

# Frecuencia relativa acumulada 
frecuencia_rel_acum <- acumulada_manual(frecuencia_rel)

# Mostrar frecuencia relativa
cat("Frecuencia relativa:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_rel[i], "\n")
cat("\n")

# Mostrar frecuencia relativa acumulada
cat("Frecuencia relativa acumulada:\n")
for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_rel_acum[i], "\n")
cat("\n")

# Calcular media
# Se calcula la media de 'distancia' usando la función manual
media <- media_manual(s$distancia)
# Mostrar la media
cat("Media:", media, "\n")

# Varianza muestral y poblacional
# Se calcula la varianza poblacional manual
varianza_poblacional <- varianza_poblacional_manual(s$distancia)
# Se calcula la varianza muestral manual
varianza_muestral <- varianza_muestral_manual(s$distancia)
# Se calcula la desviación estándar poblacional como raíz de la varianza poblacional
desv_est_poblacional <- desv_estandar(varianza_poblacional)
# Se calcula la desviación estándar muestral como raíz de la varianza muestral
desv_est_muestral <- desv_estandar(varianza_muestral)

# Mostrar varianzas y desviaciones estándar
cat("Varianza poblacional:", varianza_poblacional, "\n")
cat("Desviación estándar poblacional:", desv_est_poblacional, "\n")
cat("Varianza muestral:", varianza_muestral, "\n")
cat("Desviación estándar muestral:", desv_est_muestral, "\n")

# ==============================================================================
# EJERCICIO 2.2: ASOCIACIONES
# ==============================================================================

# install.packages("Matrix")
# install.packages("arules")
library(Matrix)
library(arules)

#Se define la muestra
muestra<-Matrix(c(1,1,1,1,0,0, 1,1,0,1,1,0, 1,1,1,0,0,0, 1,0,1,1,1,0, 1,1,0,1,0,0, 0,0,1,0,0,0, 1,1,0,1,0,0, 0,0,0,0,1,1), 8, 6, byrow=TRUE, dimnames = list(c("suceso1", "suceso2", "suceso3", "suceso4", "suceso5", "suceso6", "suceso7", "suceso8"), c("Faros de Xenon", "Control de Velocidad", "Navegador", "Bluetooth", "Techo Solar", "Alarma")),sparse=TRUE)

#Se transforma el formato de la muestra
muestrangCMatrix<-as(muestra, "nsparseMatrix")
# muestrangCMatrix

#Se transpone la muestra
trapmuestrangCMatrix<-t(muestrangCMatrix)
# trapmuestrangCMatrix

#Se cambia el formato de la muestra transpuesta
transacciones<-as(trapmuestrangCMatrix, "transactions")
# transacciones

#Se muestra un resumen del estado de la muestra
summary(transacciones)

#1ª FASE ----------------------------------------------------------------------------------------

#Se calcula la frecuencia
frequency <- itemFrequency(transacciones, type ="absolute")
# frequency

#Se define el umbra de aceptación de soporte
support_threshold <- 0.5
numero_sucesos <-length(transacciones)
support_sucesos <-frequency/numero_sucesos
# support_sucesos

#Se filtra los sucesos elementales que superan el umbral de soporte
elementos_S_validos <- support_sucesos[support_sucesos >= support_threshold]
# elementos_S_validos


#2ªFASE -----------------------------------------------------------------------------------------
#Se agrupan los sucesos elementales que superaron el umbral de soporte
L1 <- c("Faros de Xenon", "Control de Velocidad", "Navegador", "Bluetooth")
# L1

#Se agrupan en una lista 
L1_lista <- lapply(L1, function(x) c(x))

#función que genera los sucesos candidatos de cada dimensión deseada
generate_candidates <- function(L_prev) {
   n <- length(L_prev)
   if (n <= 1) return(list())     
   k <- length(L_prev[[1]]) + 1
   
   # Que los sucesos candidatos estén ordenados
   L_prev <- lapply(L_prev, sort)
   candidates <- list()
   
   for (i in seq_len(n - 1)) {         
     for (j in seq(i + 1, n)) {         
       b <- L_prev[[j]]
       
       
       if (k - 2 == 0 || all(a[1:(k - 2)] == b[1:(k - 2)])) {
         new_set <- sort(unique(c(a, b)))
         if (length(new_set) == k) {
           candidates <- append(candidates, list(new_set))
         }
       }
     }
   }
   
   # eliminar duplicados (si hay)
   if (length(candidates) > 0) {
     candidates <- unique(lapply(candidates, function(x) paste(sort(x), collapse = ",")))
     candidates <- lapply(candidates, function(x) strsplit(x, ",")[[1]])
   }
   return(candidates)
}

#sucesos candidatos de dimensión 2
L2<- generate_candidates(L1_lista)
# L2

#sucesos candidatos de dimensión 3
L3 <- generate_candidates(L2)
# L3

#sucesos candidatos de dimensión 4
L4 <- generate_candidates(L3)
# L4


#3º FASE ----------------------------------------------------------------------------------------------------

#se crea diccionario para cambiar las palabras por números
item_map <- c(
   "Faros de Xenon" = 1,
   "Control de Velocidad" = 2,
   "Navegador" = 3,
   "Bluetooth" = 4,
   "Techo Solar" = 5,
   "Alarma" = 6
)

#función que camibia las palabras de los sucesos por números con un orden ascendente los números
encode_candidates <- function(candidates, mapping) {
   lapply(candidates, function(subset) {
     nums <- unname(mapping[subset])     
     sort(nums)                         
   })
}

#Se obtienes los sucesos candidatos codificados
L2_numerico <- encode_candidates(L2, item_map)
L3_numerico <- encode_candidates(L3, item_map)
L4_numerico <- encode_candidates(L4, item_map)
# L2_numerico

# 4º FASE -----------------------------------------------------------------------------------------------

#Se agrupan todos los candidatos en una lista común
all_candidates <- c(L2_numerico, L3_numerico, L4_numerico)

#Se agrupan los sucesos candidatos en lista de cada uno con su dimensión
L2_candidatos <- Filter(function(x) length(x) == 2, all_candidates)
L3_candidatos <- Filter(function(x) length(x) == 3, all_candidates)
L4_candidatos <- Filter(function(x) length(x) == 4, all_candidates)


#función que crea el nodo árbol de cada suceso candidato para el hash tree
make_node <- function(item = NULL, is_end = FALSE) {
   node <- new.env(parent = emptyenv()) 
   node$item <- item
   node$children <- list() 
   node$is_end <- is_end
   node
}



#función que inserta las codificaciones de los sucesos candidatos, colocandolos en la posición correspondiente
insert_candidate <- function(root, candidate) {
   current <- root
   for (it in candidate) {
     key <- as.character(it)
     if (!(key %in% names(current$children))) {
       current$children[[key]] <- make_node(item = it, is_end = FALSE)
     }
     current <- current$children[[key]]
   }
   current$is_end <- TRUE
   invisible(NULL)
}



#función que inicia el proceso de creación de un hash tree
build_tree <- function(candidates) {
   root <- make_node(item = NULL, is_end = FALSE)
   for (cand in candidates) {
     insert_candidate(root, cand)
   }
   root
}



# función para imprimir el hash tree
print_tree <- function(node, depth = 0) {
   indent <- paste(rep("  ", depth), collapse = "")
   if (is.null(node$item)) {
     cat("(root)\n")
   } else {
     cat(indent, "- ", node$item, if (node$is_end) " [end]\n" else "\n", sep = "")
   }
   if (length(node$children) > 0) {
     keys <- as.integer(names(node$children))
     keys <- sort(keys, na.last = TRUE)
     for (k in as.character(keys)) {
       print_tree(node$children[[k]], depth + 1)
     }
   }
}

#Se crean los hash trees de los sucesos candidatos para cada dimensión
arbol_L2_candidatos <- build_tree(L2_candidatos)
arbol_L3_candidatos <- build_tree(L3_candidatos)
arbol_L4_candidatos <- build_tree(L4_candidatos) 

#Se imprime uno de los árboles
print_tree(arbol_L2_candidatos)




#Se crean los árboles de los conjuntos de la muestra para cada dimensión

#Se transforman los elementos del conjunto de la muestra en su versión númerica y ordenada
transactions_num <- apply(muestra, 1, function(row) {
   items <- names(row[row == 1])
   nums <- unname(item_map[items])
   sort(nums)
})

# transactions_num


# función que genera todas la combinaciones posibles de un conjunto numérico de la muestra en la dimensión deseada
generate_subsets <- function(items, k) {
   if (length(items) < k) return(list())
   combn(items, k, simplify = FALSE)
}

#Se crean las combinaciones posibles para cada conjunto de la muestra
transaction_subsets <- lapply(transactions_num, function(items) {
   list(
     C2 = generate_subsets(items, 2),
     C3 = generate_subsets(items, 3),
     C4 = generate_subsets(items, 4)
   )
})

#Se usa la función build tree sobre cada una de las combinaciones de los sucesos de la muestra
all_trees <- lapply(transaction_subsets, function(subs) {
   list(
     tree_C2 = if (length(subs$C2) > 0) build_tree(subs$C2) else NULL,
     tree_C3 = if (length(subs$C3) > 0) build_tree(subs$C3) else NULL,
     tree_C4 = if (length(subs$C4) > 0) build_tree(subs$C4) else NULL
   )
})

#Se imprime el árbol de dimensión 2 del suceso 1 de la muestra
print_tree(all_trees$suceso1$tree_C2)


#5º FASE ------------------------------------------------------------------


# Función que recoje todos las hojas del árbol para posteriormente poder contar las apariciones
get_leaf_paths <- function(node, current_path = integer()) {
   paths <- list()
   if (!is.null(node$item)) {
     current_path <- c(current_path, node$item)
   }
   if (node$is_end) {
     paths <- append(paths, list(current_path))
   }
   if (length(node$children) > 0) {
     for (child in node$children) {
       paths <- append(paths, get_leaf_paths(child, current_path))
     }
   }
   paths
}

#Se obtienen las hojas del árbol suceso candidato de dimensión 2
hojas_L2_candidato <- get_leaf_paths(arbol_L2_candidatos)
# hojas_L2_candidato

#Función que comprueba si existe una de las hojas de los árboles de los sucesos candidatos en un árbol
path_in_tree <- function(tree, path) {
   current <- tree
   for (item in path) {
     key <- as.character(item)
     if (!(key %in% names(current$children))) {
       return(FALSE)
     }
     current <- current$children[[key]]
   }
   return(TRUE)
}



#función que cuenta el número de apariciones de las hojas de los sucesos candidatos en los árboles de la muestra
count_supports <- function(candidate_tree, sample_trees_by_level) {
   candidate_paths <- get_leaf_paths(candidate_tree)
   supports <- numeric(length(candidate_paths))
   
   for (i in seq_along(candidate_paths)) {
     path <- candidate_paths[[i]]
     supports[i] <- sum(sapply(sample_trees_by_level, function(trees) {
       tree_level <- NULL
       k <- length(path)
       if (k == 2) tree_level <- trees$tree_C2
       else if (k == 3) tree_level <- trees$tree_C3
       else if (k == 4) tree_level <- trees$tree_C4
       if (is.null(tree_level)) return(FALSE)
       path_in_tree(tree_level, path)
     }))
   }
   
   data.frame(
     itemset = sapply(candidate_paths, function(p) paste(p, collapse = ",")),
     support = supports
   )
}


#Se obtienen los soportes de cada dimensión de los árboles candidatos
soporte_arbol_L2 <- count_supports(arbol_L2_candidatos, all_trees)
soporte_arbol_L3 <- count_supports(arbol_L3_candidatos, all_trees)
soporte_arbol_L4 <- count_supports(arbol_L4_candidatos, all_trees)

#Se imprimen los soportes de los árboles candidatos
soporte_arbol_L2
soporte_arbol_L3
soporte_arbol_L4



#función que filtra los sosportes de los árboles que superan el umbral
filter_by_threshold <- function(support_df, threshold, total_tx) {
   support_df$support_ratio <- support_df$support / total_tx
   subset(support_df, support_ratio >= threshold)
}

#Se obtienen los árboles con los elementos que superan el umbral de soporte
L2_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L2, support_threshold, numero_sucesos)
L3_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L3, support_threshold, numero_sucesos)
L4_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L4, support_threshold, numero_sucesos)

Se imprimen los árboles sucesos candidatos despues de observar cuales superan el soporte
L2_candidatos_post_arbol
L3_candidatos_post_arbol
L4_candidatos_post_arbol




#6ª FASE--------------------------------------------------------------------------------------------------
#Se revierten los números a palabras
item_map_rev <- setNames(names(item_map), item_map)

#función que genera las asociaciones posibles para cada suceso candidatos
generate_associations <- function(itemset) {
 k <- length(itemset)
   associations <- list()
   if (k < 2) return(associations)
 
   all_subsets <- unlist(lapply(1:(k - 1), function(i) combn(itemset, i, simplify = FALSE)), recursive = FALSE)
 
   for (lhs in all_subsets) {
     rhs <- setdiff(itemset, lhs)
     associations <- append(associations, list(list(lhs = lhs, rhs = rhs)))
   }
   associations
}

#convierte el texto a un vector numérico
split_itemset <- function(s) as.integer(unlist(strsplit(s, ",")))

#función que orquesta todo el proceso de creación de las asociaciones
create_associations_from_L <- function(L_df) {
 if (nrow(L_df) == 0) return(data.frame())
   
   all_associations <- list()
   for (i in seq_len(nrow(L_df))) {
     itemset <- split_itemset(L_df$itemset[i])
     associations <- generate_associations(itemset)
     all_associations <- append(all_associations, lapply(associations, function(r) {
       data.frame(
         lhs = paste(item_map_rev[as.character(sort(r$lhs))], collapse = ", "),
         rhs = paste(item_map_rev[as.character(sort(r$rhs))], collapse = ", "),
         k = length(itemset),
         support = L_df$support[i],
         support_ratio = L_df$support_ratio[i],
         stringsAsFactors = FALSE
       )
     }))
   }
   do.call(rbind, all_associations)
}

#Se crean las asociaciones
associaciones_L2 <- create_associations_from_L(L2_candidatos_post_arbol)
associaciones_L3 <- create_associations_from_L(L3_candidatos_post_arbol)
associaciones_L4 <- create_associations_from_L(L4_candidatos_post_arbol)

#Se imprimen las asociaciones creadas para la dimensión 2
associaciones_L2


#7ª FASE -----------------------------------------------------------------------------------

#Se define el umbral de confianza
confidence_threshold <- 0.8

#función que ayuda a crear la tabla de búsqueda convirtiendo los números a palabras
convert_numeric_str_to_text_str <- function(num_str, map_rev) {
   nums_numeric <- split_itemset(num_str) 
   nums_char <- as.character(nums_numeric)
   names <- unname(map_rev[nums_char])
   paste(names, collapse = ", ") 
}

#Se crea data frame para usarlo de búsqueda para la dimensión 1
soporte_L1_map_df <- data.frame(
   lhs_str = names(frequency),
   lhs_support = as.integer(frequency),
   stringsAsFactors = FALSE
)

#Se crea data frame para usarlo de búsqueda para la dimensión 2
soporte_L2_map_df <- data.frame(
   lhs_str = sapply(soporte_arbol_L2$itemset, convert_numeric_str_to_text_str, map_rev = item_map_rev),
   lhs_support = soporte_arbol_L2$support,
   stringsAsFactors = FALSE
)
#Se crea data frame para usarlo de búsqueda para la dimensión 3
soporte_L3_map_df <- data.frame(
   lhs_str = sapply(soporte_arbol_L3$itemset, convert_numeric_str_to_text_str, map_rev = item_map_rev),
   lhs_support = soporte_arbol_L3$support,
   stringsAsFactors = FALSE
)

#Se combinan tosas las anteriores en una sola tabla maestra
master_support_lookup <- rbind(soporte_L1_map_df, soporte_L2_map_df, soporte_L3_map_df)
master_support_lookup <- na.omit(master_support_lookup)


#Función que devuelve los valores de confianza para cada regla de asociación
calculate_and_filter_confidence <- function(associations_df, support_lookup, threshold) {
   if (nrow(associations_df) == 0) {
     return(data.frame(
       lhs = character(),
       rhs = character(),
       k = integer(),
       support_ratio = numeric(),
       confidence = numeric(),
       stringsAsFactors = FALSE
     ))
   }
   
   merged_df <- merge(associations_df, support_lookup, by.x = "lhs", by.y = "lhs_str", all.x = TRUE)
   
   merged_df$lhs_support[is.na(merged_df$lhs_support)] <- 0
   
   merged_df$confidence <- merged_df$support / merged_df$lhs_support
   
   merged_df$confidence[is.nan(merged_df$confidence)] <- 0
   
   strong_rules <- merged_df[, c("lhs", "rhs", "k", "support_ratio", "confidence")]
  
   strong_rules[order(-strong_rules$confidence), ]
}

#Se obtienen las asociaciones con las confianzas
reglas_fuertes_L2 <- calculate_and_filter_confidence(associaciones_L2, master_support_lookup, confidence_threshold)
reglas_fuertes_L3 <- calculate_and_filter_confidence(associaciones_L3, master_support_lookup, confidence_threshold)
reglas_fuertes_L4 <- calculate_and_filter_confidence(associaciones_L4, master_support_lookup, confidence_threshold)


# Filtrado final, se obtienen las reglas de asociación que superan el umbral de confianza
reglas_finales_L2 <- subset(reglas_fuertes_L2, confidence >= confidence_threshold)
reglas_finales_L3 <- subset(reglas_fuertes_L3, confidence >= confidence_threshold)
reglas_finales_L4 <- subset(reglas_fuertes_L4, confidence >= confidence_threshold)

print("--- Reglas que superan el umbral de confianza (0.8) ---")
print(reglas_finales_L2)
print(reglas_finales_L3)
print(reglas_finales_L4)



# ==============================================================================
# EJERCICIO 2.3: Análisis de detección de datos anómalos utilizando técnicas con base estadística.
# ==============================================================================

# CREACIÓN DEL CONJUNTO DE DATOS.
# Se crea un data frame con dos variables: Velocidad y Temperatura
# Cada fila representa una observación independiente
datos <- data.frame(
  Velocidad = c(10,8,13,9,11,14,6,4,12,7,5),
  Temperatura = c(7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73)
)

# FUNCIONES AUXILIARES BÁSICAS.

# Contar elementos manualmente
contar_elementos <- function(x) {
  n <- 0
  for (._ in x) n <- n + 1 # Incrementa n por cada elemento
  n
}

# Suma manual
mi_suma <- function(x) {
  total <- 0
  for (valor in x) total <- total + valor # Suma acumulativa de los valores
  total
}

# Media manual
media_manual <- function(x) {
  suma <- mi_suma(x)
  n <- contar_elementos(x)
  suma / n
}

# Varianza manual
varianza_manual <- function(x) {
  n <- contar_elementos(x)     # Número de elementos
  media <- media_manual(x)     # Media del vector
  suma <- 0
  for (v in x) suma <- suma + (v - media)^2   # Suma de desviaciones al cuadrado
  suma / n                   # Varianza = suma de cuadrados / n
}

# Desviación típica manual
desviacion_manual <- function(x) {
  sqrt(varianza_manual(x))
}


#FUNCIONES PARA CADA MÉTODO.


# Método IQR manual

detectar_outliers_iqr <- function(x) {
  resumen <- fivenum(x)      # Calcula los cinco números resumen: min, Q1, mediana, Q3, max
  Q1 <- resumen[2]           # Primer cuartil
  Q3 <- resumen[4]           # Tercer cuartil
  IQRv <- Q3 - Q1            # Rango intercuartílico
  lim_inf <- Q1 - 1.5 * IQRv # Límite inferior para detectar outliers
  lim_sup <- Q3 + 1.5 * IQRv # Límite superior para detectar outliers
  
  cat("\n--- DETECCIÓN OUTLIERS IQR ---\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  
  i <- 1
  hay_outliers <- FALSE
  for (v in x) {
    if (v < lim_inf || v > lim_sup) { # Si el valor está fuera de los límites
      cat("Índice:", i, "→ Valor =", v, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}


# Método de la desviación típica manual

detectar_outliers_sd <- function(x, d = 2) {
  media <- media_manual(x)
  desv <- desviacion_manual(x)
  lim_inf <- media - d * desv
  lim_sup <- media + d * desv
  
  cat("\n--- DETECCIÓN OUTLIERS DESVIACIÓN TÍPICA ---\n")
  cat("Media:", media, "\n")
  cat("Desviación típica:", desv, "\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  
  i <- 1
  hay_outliers <- FALSE
  for (valor in x) {
    if (valor < lim_inf || valor > lim_sup) {
      cat("Índice:", i, "→ Valor =", valor, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}


# Método de regresión manual con detección por residuos

detectar_outliers_regresion <- function(x, y, d = 2) {
  n <- contar_elementos(x)  # Número de observaciones
  media_x <- media_manual(x)
  media_y <- media_manual(y)
  
  # Calcular los coeficientes de la recta de regresión y = b0 + b1*x
  num <- 0
  den <- 0
  for (i in seq(n)) {
    num <- num + (x[i] - media_x) * (y[i] - media_y)
    den <- den + (x[i] - media_x)^2
  }
  b1 <- num / den # Pendiente
  b0 <- media_y - b1 * media_x
  
  # Calcular residuos (diferencia entre y observado y y estimado)
  residuos <- numeric(n)
  for (i in seq(n)) {
    y_est <- b0 + b1 * x[i]
    residuos[i] <- y[i] - y_est
  }
  
  # Calcular error estándar de residuos
  suma_res <- 0
  for (r in residuos) suma_res <- suma_res + r^2
  error_est <- sqrt(suma_res / n)
  
  cat("\n--- DETECCIÓN OUTLIERS REGRESIÓN ---\n")
  cat("Ecuación: y =", round(b0, 4), "+", round(b1, 4), "* x\n")
  cat("Error estándar de residuos:", round(error_est, 4), "\n")
  
  i <- 1
  hay_outliers <- FALSE
  for (r in residuos) {
    if (abs(r) > d * error_est) { # Si el residuo supera d veces el error estándar
      cat("Índice:", i, "→ Residuo =", round(r, 4), "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers en los residuos.\n")
}

# APLICACIÓN DE LOS MÉTODOS

detectar_outliers_iqr(datos$Velocidad)
detectar_outliers_sd(datos$Temperatura)
detectar_outliers_regresion(datos$Velocidad, datos$Temperatura)


# ==============================================================================
# EJERCICIO 2.4: DETECCIÓN DE OUTLIERS MANUAL (K-NN y LOF)
# ==============================================================================

# --- 0. Carga de Datos ---
# Se asume que 'seminarios.txt' está en el directorio de trabajo.

if (!exists("s_bio")) {
  s_bio <- read.table("seminarios.txt", header = TRUE)
}

cat(">> Conjunto de datos (Asistencia):\n")
print(s_bio)

# Preparación común
datos_m <- as.matrix(s_bio)
n <- nrow(datos_m)

# ==============================================================================
# PARTE 1: K-NN MANUAL (Proximidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 1: K-NN MANUAL (Proximidad)\n")
cat("********************************************************************\n")

# Parámetros
K_knn <- 3
UMBRAL_DIST_KNN <- 5

# --- Paso 1: Cálculo Manual Matriz Distancias (Euclídea) ---
cat("\n[Paso 1] Matriz de Distancias Euclídeas:\n")
matriz_dist_euclidea <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = sqrt( (x1-x2)^2 + (y1-y2)^2 )
    matriz_dist_euclidea[i, j] <- sqrt((datos_m[i,1] - datos_m[j,1])^2 + 
                                       (datos_m[i,2] - datos_m[j,2])^2)
  }
}
print(round(matriz_dist_euclidea, 2))

# --- Paso 2: Análisis de Vecinos y Detección ---
cat("\n[Paso 2 & 3] Análisis de Vecindad (K =", K_knn, ") y Detección:\n")

for (i in 1:n) {
  dists_punto <- matriz_dist_euclidea[i, ]
  orden_vecinos <- order(dists_punto)
  
  # Los vecinos reales empiezan en el índice 2 (el 1 es el propio punto)
  indices_k_vecinos <- orden_vecinos[2:(K_knn + 1)]
  dist_k_esimo <- dists_punto[orden_vecinos[K_knn + 1]]
  
  # Mostrar detalle de los vecinos
  cat("\n--- Analizando Punto P", i, " ---\n", sep="")
  # Desglose de los 3 vecinos más cercanos
  for (k in 1:K_knn) {
     vecino_idx <- orden_vecinos[k+1]
     cat("   ", k, "º Vecino más cercano: P", vecino_idx, 
         " (Distancia: ", round(dists_punto[vecino_idx], 2), ")\n", sep="")
  }
  
  # Decisión final para el punto
  es_outlier <- dist_k_esimo > UMBRAL_DIST_KNN
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER!" else "-> Normal"
  
  cat(">> CONCLUSIÓN P", i, ": Distancia al 3er vecino = ", 
      round(dist_k_esimo, 2), " ", estado, "\n", sep="")
}


# ==============================================================================
# PARTE 2: LOF MANUAL (Densidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 2: LOF MANUAL (Densidad)\n")
cat("********************************************************************\n")

# Parámetros
K_lof <- 3
UMBRAL_DRM <- 0.8

# --- Paso Previo: Matriz Distancias Manhattan  ---
cat("\n[Paso Previo] Recálculo con Distancia Manhattan (para LOF):\n")
matriz_dist_manhattan <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = |x1-x2| + |y1-y2|
    matriz_dist_manhattan[i, j] <- abs(datos_m[i,1] - datos_m[j,1]) + 
                                   abs(datos_m[i,2] - datos_m[j,2])
  }
}
print(matriz_dist_manhattan)

# --- FASE A: Cálculo de Densidades Locales ---
cat("\n[FASE A] Cálculo de Densidad Local (d) para cada punto:\n")
cat("Fórmula: d(Pi) = ( Suma_distancias_a_K_vecinos / K )^-1\n\n")

densidad_local <- numeric(n)
vecinos_indices_lista <- vector("list", n) # Necesario para Fase B

for (i in 1:n) {
  dists <- matriz_dist_manhattan[i, ]
  orden <- order(dists)
  
  # Identificar los K vecinos
  mis_vecinos_idx <- orden[2:(K_lof + 1)]
  vecinos_indices_lista[[i]] <- mis_vecinos_idx
  
  # Suma de distancias
  suma_dist <- sum(dists[mis_vecinos_idx])
  
  # Cálculo de densidad
  densidad_local[i] <- (suma_dist / K_lof)^-1
  
  # Salida detallada
  vecinos_str <- paste("P", mis_vecinos_idx, sep="", collapse=", ")
  cat("P", i, ": Vecinos {", vecinos_str, "} | Suma Distancias: ", suma_dist,
      " | Densidad d(P", i, "): ", round(densidad_local[i], 4), "\n", sep="")
}

# --- FASE B: Cálculo de Densidad Relativa Media (drm) ---
cat("\n[FASE B] Cálculo de Densidad Relativa Media (drm):\n")
cat("Fórmula: drm(Pi) = d(Pi) / Media( d(vecinos_de_Pi) )\n\n")

drm_scores <- numeric(n)

for (i in 1:n) {
  # 1. Densidad propia
  mi_densidad <- densidad_local[i]
  
  # 2. Densidades de mis vecinos (recuperadas de la lista guardada en Fase A)
  indices_mis_vecinos <- vecinos_indices_lista[[i]]
  densidades_vecinos <- densidad_local[indices_mis_vecinos]
  
  # 3. Media de las densidades de los vecinos
  media_dens_vecinos <- mean(densidades_vecinos)
  
  # 4. Cálculo del drm
  drm_scores[i] <- mi_densidad / media_dens_vecinos
  
  # Salida detallada mostrando la comparación
  cat("P", i, " -> Mi Densidad: ", round(mi_densidad, 3), 
      " | Media Dens. Vecinos (P", paste(indices_mis_vecinos, collapse=",P"), 
      "): ", round(media_dens_vecinos, 3), 
      " | drm: ", round(drm_scores[i], 4), "\n", sep="")
}

# --- FASE C: Detección Final ---
cat("\n[FASE C] Resultados Finales LOF (Umbral drm <", UMBRAL_DRM, "):\n", sep="")

for (i in 1:n) {
  es_outlier <- drm_scores[i] < UMBRAL_DRM
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER! (Densidad relativa muy baja)" else "-> Normal"
  cat(sprintf("Punto P%d | drm = %.4f \t%s\n", i, drm_scores[i], estado))
}

cat("\n********************************************************************\n")
cat(" FIN DEL ANÁLISIS MANUAL EJERCICIO 2.4\n")
cat("********************************************************************\n")
