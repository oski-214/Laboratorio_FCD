> setwd("C:/Users/oscar/OneDrive - Universidad de Alcala/One_drive Personal/Documentos/INFOADE CARRERA UAH/25-26/1º Cuatri/Fundamentos Ciencia Datos/Práctica/R/Trabajo_R")
> # ==============================================================================
> # MASTER SCRIPT: FUNDAMENTOS DE CIENCIA DE DATOS (PL1)
> # ==============================================================================
> 
> # ==============================================================================
> # EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO GUIADO (Satélites de Urano)
> # Usa funciones estándar de R base.
> # ==============================================================================
> cat("\n\n********************************************************************\n")


********************************************************************
> cat(" EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO (SATÉLITES URANO)\n")
 EJERCICIO 1.1: ANÁLISIS DESCRIPTIVO (SATÉLITES URANO)
> cat("********************************************************************\n")
********************************************************************
> 
> # --- 1. Carga de datos ---
> # Asegúrate de tener 'satelites.txt' en tu directorio de trabajo (setwd)
> # Contenido esperado de satelites.txt:
> # nombre radio
> # Cordelia 13
> # Ofelia 16
> # ...
> s <- read.table("satelites.txt", header = TRUE)
> print(">> Conjunto de datos original:")
[1] ">> Conjunto de datos original:"
> print(s)
        nombre radio
1     Cordelia    13
2       Ofelia    16
3       bianca    22
4       quesia    33
5    desdemora    29
6      julieta    42
7    Rosalinda    27
8      belinda    34
9  luna1986u10    20
10    calibano    30
11    luna9991    20
12  luna1999u2    15
> 
> # --- 2. Ordenación ---
> # Orden ascendente por radio
> so_asc <- s[order(s$radio), ]
> print(">> Datos ordenados (ascendente) por Radio:")
[1] ">> Datos ordenados (ascendente) por Radio:"
> print(so_asc)
        nombre radio
1     Cordelia    13
12  luna1999u2    15
2       Ofelia    16
9  luna1986u10    20
11    luna9991    20
3       bianca    22
7    Rosalinda    27
5    desdemora    29
10    calibano    30
4       quesia    33
8      belinda    34
6      julieta    42
> 
> # Orden descendente por radio
> so_desc <- s[rev(order(s$radio)), ]
> print(">> Datos ordenados (descendente) por Radio:")
[1] ">> Datos ordenados (descendente) por Radio:"
> print(so_desc)
        nombre radio
6      julieta    42
8      belinda    34
4       quesia    33
10    calibano    30
5    desdemora    29
7    Rosalinda    27
3       bianca    22
11    luna9991    20
9  luna1986u10    20
2       Ofelia    16
12  luna1999u2    15
1     Cordelia    13
> 
> # --- 3. Medidas de Dispersión Básicas (Rango) ---
> rango_val <- max(s$radio) - min(s$radio)
> cat("\n>> Rango del radio:", rango_val, "km\n")

>> Rango del radio: 29 km
> 
> # --- 4. Tablas de Frecuencias ---
> frec_abs <- table(s$radio)                # Frecuencia absoluta
> frec_abs_acum <- cumsum(frec_abs)         # Frecuencia absoluta acumulada
> frec_rel <- frec_abs / length(s$radio)    # Frecuencia relativa
> frec_rel_acum <- cumsum(frec_rel)         # Frecuencia relativa acumulada
> 
> # Visualización compacta en data frame
> tabla_frec <- data.frame(
+   Radio = names(frec_abs),
+   ni = as.integer(frec_abs),
+   Ni = as.integer(frec_abs_acum),
+   fi = round(as.numeric(frec_rel), 3),
+   Fi = round(as.numeric(frec_rel_acum), 3)
+ )
> cat("\n>> Tabla de Frecuencias Completa (Radio):\n")

>> Tabla de Frecuencias Completa (Radio):
> print(tabla_frec)
   Radio ni Ni    fi    Fi
1     13  1  1 0.083 0.083
2     15  1  2 0.083 0.167
3     16  1  3 0.083 0.250
4     20  2  5 0.167 0.417
5     22  1  6 0.083 0.500
6     27  1  7 0.083 0.583
7     29  1  8 0.083 0.667
8     30  1  9 0.083 0.750
9     33  1 10 0.083 0.833
10    34  1 11 0.083 0.917
11    42  1 12 0.083 1.000
> 
> # --- 5. Medidas de Tendencia Central ---
> media_r <- mean(s$radio)
> mediana_r <- median(s$radio)
> 
> cat("\n>> Medidas de Tendencia Central:\n")

>> Medidas de Tendencia Central:
> cat("   Media:", round(media_r, 2), "km\n")
   Media: 25.08 km
> cat("   Mediana:", mediana_r, "km\n")
   Mediana: 24.5 km
> 
> # --- 6. Medidas de Dispersión y Posición ---
> # Nota: var() y sd() en R calculan la versión muestral (n-1)
> var_r <- var(s$radio)
> sd_r <- sd(s$radio)
> # Cuartiles (25%, 50%, 75%)
> cuartiles <- quantile(s$radio, probs = c(0.25, 0.50, 0.75))
> 
> cat("\n>> Medidas de Dispersión y Posición:\n")

>> Medidas de Dispersión y Posición:
> cat("   Varianza (muestral):", round(var_r, 2), "\n")
   Varianza (muestral): 78.45 
> cat("   Desviación Típica (muestral):", round(sd_r, 2), "km\n")
   Desviación Típica (muestral): 8.86 km
> cat("   Cuartiles:\n")
   Cuartiles:
> print(cuartiles)
  25%   50%   75% 
19.00 24.50 30.75 
> 
> 
> 
> 
> # ==============================================================================
> # EJERCICIO 1.2: Análisis de asociación.
> # ==============================================================================
> 
> # --- Carga del paquete arules (instalar si es necesario) ---
> # install.packages("arules")  # Descomentar si no está instalado
> library(arules)
Cargando paquete requerido: Matrix

Adjuntando el paquete: ‘arules’

The following objects are masked from ‘package:base’:

    abbreviate, write

> 
> # --- Creación de la matriz binaria de cestas de compra ---
> muestra <- Matrix(
+   c(1,1,0,1,1,
+     1,1,1,1,0,
+     1,1,0,1,0,
+     1,0,1,1,0,
+     1,1,0,0,0,
+     0,0,0,1,0),
+   nrow = 6, ncol = 5, byrow = TRUE,
+   dimnames = list(
+     c("suceso1","suceso2","suceso3","suceso4","suceso5","suceso6"),
+     c("Pan","Agua","Cafe","Leche","Naranja")
+   ),
+   sparse = TRUE
+ )
> 
> # --- Conversión a matriz lógica y transposición ---
> muestrangCMatrix <- as(muestra, "nsparseMatrix")
> traspmuestrangCMatrix <- t(muestrangCMatrix)
> 
> # --- Conversión final al formato transactions ---
> transacciones <- as(traspmuestrangCMatrix, "transactions")
> 
> # --- Resumen de las transacciones ---
> summary(transacciones)
transactions as itemMatrix in sparse format with
 6 rows (elements/itemsets/transactions) and
 5 columns (items) and a density of 0.5666667 

most frequent items:
    Pan   Leche    Agua    Cafe Naranja (Other) 
      5       5       4       2       1       0 

element (itemset/transaction) length distribution:
sizes
1 2 3 4 
1 1 2 2 

   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.250   3.000   2.833   3.750   4.000 

includes extended item information - examples:
  labels
1    Pan
2   Agua
3   Cafe

includes extended transaction information - examples:
  itemsetID
1   suceso1
2   suceso2
3   suceso3
> 
> # --- Aplicación del algoritmo Apriori ---
> asociaciones <- apriori(
+   transacciones,
+   parameter = list(
+     support = 0.5,       # soporte mínimo 50%
+     confidence = 0.8     # confianza mínima 80%
+   )
+ )
Apriori

Parameter specification:
 confidence minval smax arem  aval originalSupport maxtime support minlen maxlen target  ext
        0.8    0.1    1 none FALSE            TRUE       5     0.5      1     10  rules TRUE

Algorithmic control:
 filter tree heap memopt load sort verbose
    0.1 TRUE TRUE  FALSE TRUE    2    TRUE

Absolute minimum support count: 3 

set item appearances ...[0 item(s)] done [0.00s].
set transactions ...[5 item(s), 6 transaction(s)] done [0.00s].
sorting and recoding items ... [3 item(s)] done [0.00s].
creating transaction tree ... done [0.00s].
checking subsets of size 1 2 3 done [0.00s].
writing ... [7 rule(s)] done [0.00s].
creating S4 object  ... done [0.00s].
> 
> # --- Visualización de las reglas generadas ---
> inspect(asociaciones)
    lhs              rhs     support   confidence coverage  lift count
[1] {}            => {Leche} 0.8333333 0.8333333  1.0000000 1.00 5    
[2] {}            => {Pan}   0.8333333 0.8333333  1.0000000 1.00 5    
[3] {Agua}        => {Pan}   0.6666667 1.0000000  0.6666667 1.20 4    
[4] {Pan}         => {Agua}  0.6666667 0.8000000  0.8333333 1.20 4    
[5] {Leche}       => {Pan}   0.6666667 0.8000000  0.8333333 0.96 4    
[6] {Pan}         => {Leche} 0.6666667 0.8000000  0.8333333 0.96 4    
[7] {Agua, Leche} => {Pan}   0.5000000 1.0000000  0.5000000 1.20 3    
> 
> # ==============================================================================
> # EJERCICIO 1.3: DETECCIÓN DE OUTLIERS (CAJA Y BIGOTES, DESVIACIÓN TÍPICA, REGRESIÓN)
> # ==============================================================================
> 
> # --------------------------------------------------------------------------
> # CAJA Y BIGOTES
> # --------------------------------------------------------------------------
> 
> #Introducimos los datos de la muestra en una matriz
> (muestra<-t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r", "d")))))
        r    d
[1,]  3.0  2.0
[2,]  3.5 12.0
[3,]  4.7  4.1
[4,]  5.2  4.9
[5,]  7.1  6.1
[6,]  6.2  5.2
[7,] 14.0  5.3
> 
> #Se convierte la matriz en un data frame
> (muestra<-data.frame(muestra))
     r    d
1  3.0  2.0
2  3.5 12.0
3  4.7  4.1
4  5.2  4.9
5  7.1  6.1
6  6.2  5.2
7 14.0  5.3
> 
> #Devuelve los outliers de la columna resistencia usando el range
> (boxplot(muestra$r, range=1.5, plot=FALSE))
$stats
     [,1]
[1,] 3.00
[2,] 4.10
[3,] 5.20
[4,] 6.65
[5,] 7.10

$n
[1] 7

$conf
         [,1]
[1,] 3.677181
[2,] 6.722819

$out
[1] 14

$group
[1] 1

$names
[1] "1"

> 
> #Si no se quiere emplear la función boxplot, se pueden realizar los cálculos manualmente
> #Se calcula el cuartil primero
> (cuar1r<-quantile(muestra$r, 0.25))
25% 
4.1 
> 
> #Se calcula el cuartil tercero
> (cuar3r<-quantile(muestra$r, 0.75))
 75% 
6.65 
> 
> #Se obtiene una tupla de indices que muestra los límites inferiores y superiores
> (int<-c(cuar1r-1.5*(cuar3r-cuar1r), cuar3r+1.5*(cuar3r-cuar1r)))
   25%    75% 
 0.275 10.475 
> 
> #Se observa que valores de la columna resistencia están fuera de los límites cálculados
> for (i in 1:length(muestra$r))
+ {if (muestra$r[i]<int[1] || muestra$r[i]>int[2])
+ {print("el suceso"); print(i); print(muestra$r[i]); print("es un outlier")}}
[1] "el suceso"
[1] 7
[1] 14
[1] "es un outlier"
> 
> # --------------------------------------------------------------------------
> # DESVIACIÓN TÍPICA
> # --------------------------------------------------------------------------
> 
> #Se obtiene el valor de sdd, valor que será multiplicado por el grado de outlier para definir los límites
> sdd<-sqrt(var(muestra$d)*((length(muestra$d)-1)/length(muestra$d)))
> 
> #Se obtiene una tupla de indices que muestra los límites inferiores y superiores
> (intdes<-c(mean(muestra$d)-2*sdd, mean(muestra$d)+2*sdd))
[1] -0.05685714 11.37114285
> 
> #Se observa que valores de la columna densidad están fuera de los límites cálculados
> for (i in 1:length(muestra$d))
+ {if (muestra$d[i]<intdes[1] ||  muestra$d[i]>intdes[2])
+ {print("el suceso"); print(i); print(muestra$d[i]); print("es un outlier")}}
[1] "el suceso"
[1] 2
[1] 12
[1] "es un outlier"
> 
> # --------------------------------------------------------------------------
> # REGRESIÓN
> # --------------------------------------------------------------------------
> #Se ajusta un modelo lineal
> (dfr<-lm(muestra$d~muestra$r))

Call:
lm(formula = muestra$d ~ muestra$r)

Coefficients:
(Intercept)    muestra$r  
    6.01445     -0.05723  

> 
> #Se muestra un resumen con elementos estadísticos de dicho modelo lineal
> (summary(dfr))

Call:
lm(formula = muestra$d ~ muestra$r)

Residuals:
       1        2        3        4        5        6        7 
-3.84275  6.18587 -1.64545 -0.81683  0.49192 -0.45960  0.08684 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)  
(Intercept)  6.01445    2.64632   2.273   0.0722 .
muestra$r   -0.05723    0.37148  -0.154   0.8836  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 3.372 on 5 degrees of freedom
Multiple R-squared:  0.004725,  Adjusted R-squared:  -0.1943 
F-statistic: 0.02374 on 1 and 5 DF,  p-value: 0.8836

> 
> #Se obtienes los valores predichos 
> (res<-summary(dfr)$residuals)
         1          2          3          4          5          6          7 
-3.8427477  6.1858698 -1.6454482 -0.8168308  0.4919157 -0.4595958  0.0868370 
> 
> #Se obtiene el error estandar de los residuos
> sr<-sqrt(sum(res^2)/length(res))
> 
> #Se imprime el valor del error estandar de los residuos
> sr
[1] 2.850242
> 
> Se itera sobre todos los valores predichos para ver cuales superan el límite de d*sr 
Error: unexpected symbol en "Se itera"
> for (i in 1:length(res))
+ {if (res[i]>2*sr)
+ {print("el suceso"); print(res[i]); print("es un outlier")}}
[1] "el suceso"
      2 
6.18587 
[1] "es un outlier"
> 
> # ==============================================================================
> # EJERCICIO 1.4: DETECCIÓN DE OUTLIERS (K-VECINOS Y LOF)
> # ==============================================================================
> 
> # --------------------------------------------------------------------------
> # FASE 1: K-VECINOS
> # --------------------------------------------------------------------------
> 
> # En primer lugar metemos los datos
> (muestra<-matrix(c(4,4,4,3,5,5,1,1,5,4),2,5))
     [,1] [,2] [,3] [,4] [,5]
[1,]    4    4    5    1    5
[2,]    4    3    5    1    4
> 
> # Luego hacemos:
> (muestra<-t(muestra))
     [,1] [,2]
[1,]    4    4
[2,]    4    3
[3,]    5    5
[4,]    1    1
[5,]    5    4
> 
> # Calculamos las distancias con la función dist (distancias euclídeas) 
> # y las metemos en una matriz
> (distancias=as.matrix(dist(muestra)))
         1        2        3        4        5
1 0.000000 1.000000 1.414214 4.242641 1.000000
2 1.000000 0.000000 2.236068 3.605551 1.414214
3 1.414214 2.236068 0.000000 5.656854 1.000000
4 4.242641 3.605551 5.656854 0.000000 5.000000
5 1.000000 1.414214 1.000000 5.000000 0.000000
> 
> # Y definimos las distancias como una matriz 5x5
> (distancias=matrix(distancias,5,5))
         [,1]     [,2]     [,3]     [,4]     [,5]
[1,] 0.000000 1.000000 1.414214 4.242641 1.000000
[2,] 1.000000 0.000000 2.236068 3.605551 1.414214
[3,] 1.414214 2.236068 0.000000 5.656854 1.000000
[4,] 4.242641 3.605551 5.656854 0.000000 5.000000
[5,] 1.000000 1.414214 1.000000 5.000000 0.000000
> 
> # Cogemos 3 k-vecinos para buscar los outliers, pero como cuenta cada punto consigo mismo,
> # debemos buscar la 4 distancia. Cogemos las columnas y las ordenamos.
> for(i in 1:5) {distancias[,i]=sort(distancias[,i])}; (distanciasord=distancias)
         [,1]     [,2]     [,3]     [,4]     [,5]
[1,] 0.000000 0.000000 0.000000 0.000000 0.000000
[2,] 1.000000 1.000000 1.000000 3.605551 1.000000
[3,] 1.000000 1.414214 1.414214 4.242641 1.000000
[4,] 1.414214 2.236068 2.236068 5.000000 1.414214
[5,] 4.242641 3.605551 5.656854 5.656854 5.000000
> 
> # Ahora buscamos aquellos k-3 vecinos que estén a una distancia mayor de aquella que definimos
> # para encontrar los outliers, es decir, la columna cuya 4ª fila sea mayor a la distancia dada,
> # es un outlier.
> for (i in 1:5) {if (distanciasord[4,i]>2.5) {print(i); print("es un outlier")}}
[1] 4
[1] "es un outlier"
> 
> # --------------------------------------------------------------------------
> # FASE 2: LOF
> # --------------------------------------------------------------------------
> 
> # Se instala el paquete Rlof
> install.packages("Rlof")
Installing package into ‘C:/Users/oscar/AppData/Local/R/win-library/4.5’
(as ‘lib’ is unspecified)
--- Please select a CRAN mirror for use in this session ---
probando la URL 'https://cloud.r-project.org/bin/windows/contrib/4.5/Rlof_1.1.3.zip'
Content type 'application/zip' length 157034 bytes (153 KB)
downloaded 153 KB

package ‘Rlof’ successfully unpacked and MD5 sums checked

The downloaded binary packages are in
        C:\Users\oscar\AppData\Local\Temp\Rtmpg7YuUz\downloaded_packages
> 
> library(Rlof)
Cargando paquete requerido: doParallel
Cargando paquete requerido: foreach
Cargando paquete requerido: iterators
Cargando paquete requerido: parallel
Avisos:
1: package ‘Rlof’ was built under R version 4.5.2 
2: package ‘doParallel’ was built under R version 4.5.2 
3: package ‘foreach’ was built under R version 4.5.2 
4: package ‘iterators’ was built under R version 4.5.2 
> 
> # Se define la matriz de datos con 5 observaciones y 2 variables
> # Las variables representan calificaciones en Teoría y Laboratorio de 5 estudiantes
> muestra <- matrix(c(4,4,
+                     4,3,
+                     5,5,
+                     1,1,
+                     5,4), 
+                   byrow = TRUE, ncol = 2)
> 
> # Se asignan nombres a las columnas y filas
> colnames(muestra) <- c("Teoria","Laboratorio")
> rownames(muestra) <- 1:5
> 
> # Se imprime la matriz de datos
> print("Matriz de datos:")
[1] "Matriz de datos:"
> print(muestra)
  Teoria Laboratorio
1      4           4
2      4           3
3      5           5
4      1           1
5      5           4
> 
> # Se elige el valor de k (número de vecinos)
> k <- 3
> 
> # Se aplica la función lof() del paquete Rlof
> lof_scores <- Rlof::lof(muestra, k = k, method = "manhattan")
> 
> # Se muestran los valores LOF redondeados a 3 decimales
> print(paste("Valores LOF para k =", k, ":"))
[1] "Valores LOF para k = 3 :"
> print(round(lof_scores, 3))
[1] 1.095 0.917 0.917 2.357 1.095
> 
> # Se establece un umbral para identificar outliers
> umbral <- 1.5
> 
> # Se identifican los índices de las observaciones que superan el umbral
> outliers <- which(lof_scores > umbral)
> 
> # Se muestran los resultados
> if (length(outliers) == 0) {
+   cat("\nNo se detectaron outliers (LOF <", umbral, ")\n")
+ } else {
+   cat("\nObservaciones detectadas como outliers (LOF >", umbral, "):\n")
+   print(outliers)
+   print("Coordenadas de los outliers:")
+   print(muestra[outliers, ])
+ }

Observaciones detectadas como outliers (LOF > 1.5 ):
[1] 4
[1] "Coordenadas de los outliers:"
     Teoria Laboratorio 
          1           1 
> 
> 
> # ==============================================================================
> # EJERCICIO 2.1: ANÁLISIS DESCRIPTIVO MANUAL
> # ==============================================================================
> 
> # ============================
> # Definición de funciones 
> # ============================
> 
> # Función para contar filas 
> contar_filas <- function(vec) {
+   # Se inicializa el contador
+   n <- 0
+   # Se itera elemento a elemento y se incrementa el contador
+   for (._ in vec) n <- n + 1
+   # Se retorna el total contado
+   n
+ }
> 
> # Función para contar columnas 
> contar_columnas <- function(df) {
+   # Se inicializa el contador
+   c <- 0
+   # Se itera sobre los nombres de las columnas y se incrementa el contador
+   for (._ in names(df)) c <- c + 1
+   # Se retorna el total contado
+   c
+ }
> 
> # Función para ordenar índices 
> ordenar_indices <- function(x, decreasing = FALSE) {
+   # Se cuenta manualmente el número de elementos
+   n <- 0
+   for (._ in x) n <- n + 1
+   # Se crea un vector con los índices 1..n
+   idx <- 1:n
+   # Se aplica un algoritmo de ordenamiento (burbuja)
+   for (i in 1:(n - 1)) {
+     for (j in (i + 1):n) {
+       # Si el orden es ascendente se compara menor que, si es descendente mayor que
+       if ((!decreasing && x[j] < x[i]) || (decreasing && x[j] > x[i])) {
+         # Intercambiar elementos
+         tmp <- x[i]; x[i] <- x[j]; x[j] <- tmp
+         # Intercambiar índices
+         tmp2 <- idx[i]; idx[i] <- idx[j]; idx[j] <- tmp2
+       }
+     }
+   }
+   # Se retornan los índices ordenados
+   idx
+ }
> 
> # Función para calcular el rango 
> rango_manual <- function(x) {
+   # Inicializar máximo y mínimo con el primer valor
+   maximo <- x[1]
+   minimo <- x[1]
+   # Iterar sobre los valores para encontrar máximo y mínimo
+   for (valor in x) {
+     # Si el valor es mayor que el máximo actual, actualizar máximo
+     if (valor > maximo) maximo <- valor
+     # Si el valor es menor que el mínimo actual, actualizar mínimo
+     if (valor < minimo) minimo <- valor
+   }
+   # Retornar el rango
+   maximo - minimo
+ }
> 
> # Función para obtener valores únicos
> valores_unicos_manual <- function(x) {
+   # En primer lugar, se crea un vector vacío para almacenar los valores únicos
+   unicos <- c()
+   # Se itera sobre cada valor
+   for (v in x) {
+     # Flag para indicar si el valor ya fue encontrado
+     encontrado <- FALSE
+     # Se verifica si el valor ya está en el vector de valores únicos
+     for (u in unicos) {
+       if (v == u) { encontrado <- TRUE; break }
+     }
+     # Si el valor no fue encontrado, se agrega al vector de valores únicos
+     if (!encontrado) unicos <- c(unicos, v)
+   }
+   # Se ordenan los valores únicos y se retornan
+   unicos[ordenar_indices(unicos)]
+ }
> 
> # Función para contar cuántos elementos hay en un vector (sin length)
> contar_elementos <- function(x) {
+   # Se inicializa el contador
+   n <- 0
+   # Se incrementa por cada elemento del vector
+   for (._ in x) n <- n + 1
+   # Se retorna el total
+   n
+ }
> 
> # Función para calcular la frecuencia absoluta 
> frecuencia_absoluta_manual <- function(x, valores_ordenados) {
+   # Se obtiene el número de valores únicos
+   k <- contar_elementos(valores_ordenados)
+   # Inicializar el vector de frecuencias absolutas
+   frec <- numeric(k)
+   # Se itera sobre cada valor observado
+   for (v in x) {
+     # Se compara con cada valor único
+     for (i in 1:k) {
+       # Si coincide, se incrementa la frecuencia absoluta correspondiente
+       if (v == valores_ordenados[i]) { frec[i] <- frec[i] + 1; break }
+     }
+   }
+   # Se retorna el vector de frecuencias
+   frec
+ }
> 
> # Función para calcular la frecuencia acumulada 
> acumulada_manual <- function(vec) {
+   # Se cuenta cuántos elementos tiene el vector
+   n <- contar_elementos(vec)
+   # Inicializar el vector de frecuencias acumuladas
+   out <- numeric(n)
+   # Se suman progresivamente las frecuencias
+   acum <- 0
+   for (i in 1:n) { acum <- acum + vec[i]; out[i] <- acum }
+   # Se retorna la acumulada
+   out
+ }
> 
> # Función para calcular la frecuencia relativa manual
> relativa_manual <- function(frec_abs, total) {
+   # Se cuenta el tamaño del vector de frecuencias absolutas
+   n <- contar_elementos(frec_abs)
+   # Inicializar el vector de frecuencias relativas
+   out <- numeric(n)
+   # Se calcula dividiendo la frecuencia absoluta entre el total de filas
+   for (i in 1:n) out[i] <- frec_abs[i] / total
+   # Se retorna la frecuencia relativa
+   out
+ }
> 
> # Función para calcular la media 
> media_manual <- function(x) {
+   # Se incializa la suma a cero
+   suma <- 0
+   # Se cuenta el número de elementos
+   n <- contar_elementos(x)
+   # Se suma cada valor
+   for (v in x) suma <- suma + v
+   # Se retorna la media
+   suma / n
+ }
> 
> # Función para calcular la varianza poblacional 
> varianza_poblacional_manual <- function(x) {
+   # Se cuenta el número de elementos
+   n <- contar_elementos(x)
+   # Se calcula la media manualmente
+   m <- media_manual(x)
+   # Se calcula la suma de los cuadrados de las diferencias respecto a la media
+   suma_cuad <- 0
+   for (v in x) suma_cuad <- suma_cuad + (v - m)^2
+   # Varianza poblacional: dividir entre N
+   suma_cuad / n
+ }
> 
> # Función para calcular la varianza muestral 
> varianza_muestral_manual <- function(x) {
+   # Se cuenta el número de elementos
+   n <- contar_elementos(x)
+   # Si no hay suficientes datos, se retorna NA
+   if (n <= 1) return(NA_real_)
+   # Se calcula la media manualmente
+   m <- media_manual(x)
+   # Se calcula la suma de los cuadrados de las diferencias respecto a la media
+   suma_cuad <- 0
+   for (v in x) suma_cuad <- suma_cuad + (v - m)^2
+   # Varianza muestral: dividir entre (N - 1)
+   suma_cuad / (n - 1)
+ }
> 
> # Función para obtener la desviación estándar a partir de una varianza
> desv_estandar <- function(varianza) {
+   # Si la varianza es NA, se retorna NA
+   if (is.na(varianza)) return(NA_real_)
+   # Se calcula la raíz cuadrada de la varianza
+   sqrt(varianza)
+ }
> 
> # ============================
> # Script principal 
> # ============================
> 
> # Se lee el archivo de datos y se indica que la primera fila contiene los nombres de las columnas
> s <- read.table("distancias.txt", header = TRUE)
> # Mostrar el data frame
> print(s)
                     nombre distancia
1               Villalbilla      16.5
2      Ensanche_de_Vallecas      34.8
3               Villalbilla      20.7
4         Alcalá_de_Henares       6.2
5         Alcalá_de_Henares       4.4
6         Alcalá_de_Henares       3.4
7                 Cifuentes      24.0
8                 Cifuentes      24.0
9                  El_Casar      32.0
10 Fuente_el_Saz_del_Jarama      30.0
11                       ND      33.0
12                  Coslada      27.0
13        Daganzo_de_Arriba      15.0
14        Alcalá_de_Henares       9.4
15        Alcalá_de_Henares       2.1
16          Arganda_del_Rey      34.0
17                  Coslada      24.0
18        Alcalá_de_Henares      12.0
19        Alcalá_de_Henares       4.4
20                   Madrid      28.0
21                   Madrid      31.4
22       Mejorada_del_Campo      21.6
23        Alcalá_de_Henares       3.1
24        Alcalá_de_Henares       4.5
25        Alcalá_de_Henares       5.1
26                       ND       4.0
27                       ND       3.2
28                       ND      25.0
29        Alcalá_de_Henares       4.5
30              Guadalajara      20.0
31              Guadalajara      34.0
32        Torrejón_de_Ardoz      12.0
33        Torrejón_de_Ardoz      12.0
34        Torrejón_de_Ardoz      12.0
35        Torrejón_de_Ardoz      12.0
36        Alcalá_de_Henares       5.0
37        Torrejón_de_Ardoz      19.0
38              Guadalajara      30.0
39                       ND       5.5
40                       ND      38.0
41              Chiloheches      25.0
42        Alcalá_de_Henares       3.7
43                       ND       9.0
44                       ND      30.0
45                       ND      13.0
46              Guadalajara      30.0
47              Guadalajara      30.0
48                  Coslada      26.0
49              Guadalajara      30.0
50     Cabanillas_del_Campo      30.0
51        Alcalá_de_Henares       1.0
52                   Madrid      26.0
53                       ND      22.0
54                       ND      10.0
55                  Daganzo       9.7
56        Alcalá_de_Henares      11.0
57     Torres_de_la_Alameda      24.1
58   Velilla_de_San_Antonio      33.0
59                  Daganzo      17.2
60              Guadalajara      27.0
61                       ND      24.0
62              Guadalajara      27.0
63                   Cobeña      21.0
64                Galapagos      28.0
65                   Madrid      30.0
66        Alcalá_de_Henares       4.0
67                   Madrid      46.0
68                  Coslada      29.0
69                       ND       3.7
70        Alcalá_de_Henares       2.7
71                       ND       8.1
72                  Alovera      19.0
73        Torrejón_de_Ardoz      16.0
> 
> # Contar filas manualmente
> # Se inicializa el contador de filas mediante función
> filas <- contar_filas(s$distancia)
> 
> # Contar columnas manualmente
> # Se inicializa el contador de columnas mediante función
> columnas <- contar_columnas(s)
> 
> # Mostrar dimensiones
> cat("Dimensiones (filas x columnas): ", filas, " x ", columnas, "\n", sep = "")
Dimensiones (filas x columnas): 73 x 2
> 
> # Se obtienen los índices ordenados ascendente y descendentemente
> idx_asc  <- ordenar_indices(s$distancia)
> idx_desc <- ordenar_indices(s$distancia, decreasing = TRUE)
> 
> # Se crean los data frames ordenados
> so_asc  <- s[idx_asc, ]
> so_desc <- s[idx_desc, ]
> 
> # Mostrar los data frames ordenados
> cat("Orden ascendente por distancia:\n")
Orden ascendente por distancia:
> print(so_asc)
                     nombre distancia
51        Alcalá_de_Henares       1.0
15        Alcalá_de_Henares       2.1
70        Alcalá_de_Henares       2.7
23        Alcalá_de_Henares       3.1
27                       ND       3.2
6         Alcalá_de_Henares       3.4
69                       ND       3.7
42        Alcalá_de_Henares       3.7
26                       ND       4.0
66        Alcalá_de_Henares       4.0
5         Alcalá_de_Henares       4.4
19        Alcalá_de_Henares       4.4
29        Alcalá_de_Henares       4.5
24        Alcalá_de_Henares       4.5
36        Alcalá_de_Henares       5.0
25        Alcalá_de_Henares       5.1
39                       ND       5.5
4         Alcalá_de_Henares       6.2
71                       ND       8.1
43                       ND       9.0
14        Alcalá_de_Henares       9.4
55                  Daganzo       9.7
54                       ND      10.0
56        Alcalá_de_Henares      11.0
33        Torrejón_de_Ardoz      12.0
34        Torrejón_de_Ardoz      12.0
35        Torrejón_de_Ardoz      12.0
18        Alcalá_de_Henares      12.0
32        Torrejón_de_Ardoz      12.0
45                       ND      13.0
13        Daganzo_de_Arriba      15.0
73        Torrejón_de_Ardoz      16.0
1               Villalbilla      16.5
59                  Daganzo      17.2
72                  Alovera      19.0
37        Torrejón_de_Ardoz      19.0
30              Guadalajara      20.0
3               Villalbilla      20.7
63                   Cobeña      21.0
22       Mejorada_del_Campo      21.6
53                       ND      22.0
61                       ND      24.0
17                  Coslada      24.0
8                 Cifuentes      24.0
7                 Cifuentes      24.0
57     Torres_de_la_Alameda      24.1
28                       ND      25.0
41              Chiloheches      25.0
48                  Coslada      26.0
52                   Madrid      26.0
12                  Coslada      27.0
62              Guadalajara      27.0
60              Guadalajara      27.0
20                   Madrid      28.0
64                Galapagos      28.0
68                  Coslada      29.0
65                   Madrid      30.0
50     Cabanillas_del_Campo      30.0
44                       ND      30.0
10 Fuente_el_Saz_del_Jarama      30.0
46              Guadalajara      30.0
47              Guadalajara      30.0
38              Guadalajara      30.0
49              Guadalajara      30.0
21                   Madrid      31.4
9                  El_Casar      32.0
11                       ND      33.0
58   Velilla_de_San_Antonio      33.0
16          Arganda_del_Rey      34.0
31              Guadalajara      34.0
2      Ensanche_de_Vallecas      34.8
40                       ND      38.0
67                   Madrid      46.0
> cat("\nOrden descendente por distancia:\n")

Orden descendente por distancia:
> print(so_desc)
                     nombre distancia
67                   Madrid      46.0
40                       ND      38.0
2      Ensanche_de_Vallecas      34.8
16          Arganda_del_Rey      34.0
31              Guadalajara      34.0
58   Velilla_de_San_Antonio      33.0
11                       ND      33.0
9                  El_Casar      32.0
21                   Madrid      31.4
44                       ND      30.0
46              Guadalajara      30.0
47              Guadalajara      30.0
49              Guadalajara      30.0
50     Cabanillas_del_Campo      30.0
38              Guadalajara      30.0
65                   Madrid      30.0
10 Fuente_el_Saz_del_Jarama      30.0
68                  Coslada      29.0
64                Galapagos      28.0
20                   Madrid      28.0
60              Guadalajara      27.0
62              Guadalajara      27.0
12                  Coslada      27.0
52                   Madrid      26.0
48                  Coslada      26.0
28                       ND      25.0
41              Chiloheches      25.0
57     Torres_de_la_Alameda      24.1
8                 Cifuentes      24.0
7                 Cifuentes      24.0
61                       ND      24.0
17                  Coslada      24.0
53                       ND      22.0
22       Mejorada_del_Campo      21.6
63                   Cobeña      21.0
3               Villalbilla      20.7
30              Guadalajara      20.0
37        Torrejón_de_Ardoz      19.0
72                  Alovera      19.0
59                  Daganzo      17.2
1               Villalbilla      16.5
73        Torrejón_de_Ardoz      16.0
13        Daganzo_de_Arriba      15.0
45                       ND      13.0
32        Torrejón_de_Ardoz      12.0
33        Torrejón_de_Ardoz      12.0
34        Torrejón_de_Ardoz      12.0
35        Torrejón_de_Ardoz      12.0
18        Alcalá_de_Henares      12.0
56        Alcalá_de_Henares      11.0
54                       ND      10.0
55                  Daganzo       9.7
14        Alcalá_de_Henares       9.4
43                       ND       9.0
71                       ND       8.1
4         Alcalá_de_Henares       6.2
39                       ND       5.5
25        Alcalá_de_Henares       5.1
36        Alcalá_de_Henares       5.0
29        Alcalá_de_Henares       4.5
24        Alcalá_de_Henares       4.5
5         Alcalá_de_Henares       4.4
19        Alcalá_de_Henares       4.4
66        Alcalá_de_Henares       4.0
26                       ND       4.0
69                       ND       3.7
42        Alcalá_de_Henares       3.7
6         Alcalá_de_Henares       3.4
27                       ND       3.2
23        Alcalá_de_Henares       3.1
70        Alcalá_de_Henares       2.7
15        Alcalá_de_Henares       2.1
51        Alcalá_de_Henares       1.0
> cat("\n")

> 
> # Se calcula el rango de la columna 'distancia'
> rangor <- rango_manual(s$distancia)
> # Se muestra el rango
> cat("Rango (max - min) de distancia:", rangor, "\n\n")
Rango (max - min) de distancia: 45 

> 
> # Obtener valores únicos 
> valores_unicos <- valores_unicos_manual(s$distancia)
> 
> # Contar cuántos valores únicos hay
> n_valores <- contar_elementos(valores_unicos)
> 
> # Se calcula la frecuencia absoluta
> frecuencia_abs <- frecuencia_absoluta_manual(s$distancia, valores_unicos)
> 
> # Mostrar frecuencia absoluta
> cat("Frecuencia absoluta:\n")
Frecuencia absoluta:
> for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_abs[i], "\n")
1 : 1 
2.1 : 1 
2.7 : 1 
3.1 : 1 
3.2 : 1 
3.4 : 1 
3.7 : 2 
4 : 2 
4.4 : 2 
4.5 : 2 
5 : 1 
5.1 : 1 
5.5 : 1 
6.2 : 1 
8.1 : 1 
9 : 1 
9.4 : 1 
9.7 : 1 
10 : 1 
11 : 1 
12 : 5 
13 : 1 
15 : 1 
16 : 1 
16.5 : 1 
17.2 : 1 
19 : 2 
20 : 1 
20.7 : 1 
21 : 1 
21.6 : 1 
22 : 1 
24 : 4 
24.1 : 1 
25 : 2 
26 : 2 
27 : 3 
28 : 2 
29 : 1 
30 : 8 
31.4 : 1 
32 : 1 
33 : 2 
34 : 2 
34.8 : 1 
38 : 1 
46 : 1 
> cat("\n")

> 
> # Calcular frecuencia acumulada
> frecuencia_acum <- acumulada_manual(frecuencia_abs)
> 
> # Mostrar frecuencia acumulada
> cat("Frecuencia acumulada:\n")
Frecuencia acumulada:
> for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_acum[i], "\n")
1 : 1 
2.1 : 2 
2.7 : 3 
3.1 : 4 
3.2 : 5 
3.4 : 6 
3.7 : 8 
4 : 10 
4.4 : 12 
4.5 : 14 
5 : 15 
5.1 : 16 
5.5 : 17 
6.2 : 18 
8.1 : 19 
9 : 20 
9.4 : 21 
9.7 : 22 
10 : 23 
11 : 24 
12 : 29 
13 : 30 
15 : 31 
16 : 32 
16.5 : 33 
17.2 : 34 
19 : 36 
20 : 37 
20.7 : 38 
21 : 39 
21.6 : 40 
22 : 41 
24 : 45 
24.1 : 46 
25 : 48 
26 : 50 
27 : 53 
28 : 55 
29 : 56 
30 : 64 
31.4 : 65 
32 : 66 
33 : 68 
34 : 70 
34.8 : 71 
38 : 72 
46 : 73 
> cat("\n")

> 
> # Calcular la frecuencia relativa y frecuencia relativa acumulada
> # Frecuencia relativa (frecuencia absoluta / total de filas)
> frecuencia_rel <- relativa_manual(frecuencia_abs, filas)
> 
> # Frecuencia relativa acumulada 
> frecuencia_rel_acum <- acumulada_manual(frecuencia_rel)
> 
> # Mostrar frecuencia relativa
> cat("Frecuencia relativa:\n")
Frecuencia relativa:
> for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_rel[i], "\n")
1 : 0.01369863 
2.1 : 0.01369863 
2.7 : 0.01369863 
3.1 : 0.01369863 
3.2 : 0.01369863 
3.4 : 0.01369863 
3.7 : 0.02739726 
4 : 0.02739726 
4.4 : 0.02739726 
4.5 : 0.02739726 
5 : 0.01369863 
5.1 : 0.01369863 
5.5 : 0.01369863 
6.2 : 0.01369863 
8.1 : 0.01369863 
9 : 0.01369863 
9.4 : 0.01369863 
9.7 : 0.01369863 
10 : 0.01369863 
11 : 0.01369863 
12 : 0.06849315 
13 : 0.01369863 
15 : 0.01369863 
16 : 0.01369863 
16.5 : 0.01369863 
17.2 : 0.01369863 
19 : 0.02739726 
20 : 0.01369863 
20.7 : 0.01369863 
21 : 0.01369863 
21.6 : 0.01369863 
22 : 0.01369863 
24 : 0.05479452 
24.1 : 0.01369863 
25 : 0.02739726 
26 : 0.02739726 
27 : 0.04109589 
28 : 0.02739726 
29 : 0.01369863 
30 : 0.109589 
31.4 : 0.01369863 
32 : 0.01369863 
33 : 0.02739726 
34 : 0.02739726 
34.8 : 0.01369863 
38 : 0.01369863 
46 : 0.01369863 
> cat("\n")

> 
> # Mostrar frecuencia relativa acumulada
> cat("Frecuencia relativa acumulada:\n")
Frecuencia relativa acumulada:
> for (i in 1:n_valores) cat(valores_unicos[i], ":", frecuencia_rel_acum[i], "\n")
1 : 0.01369863 
2.1 : 0.02739726 
2.7 : 0.04109589 
3.1 : 0.05479452 
3.2 : 0.06849315 
3.4 : 0.08219178 
3.7 : 0.109589 
4 : 0.1369863 
4.4 : 0.1643836 
4.5 : 0.1917808 
5 : 0.2054795 
5.1 : 0.2191781 
5.5 : 0.2328767 
6.2 : 0.2465753 
8.1 : 0.260274 
9 : 0.2739726 
9.4 : 0.2876712 
9.7 : 0.3013699 
10 : 0.3150685 
11 : 0.3287671 
12 : 0.3972603 
13 : 0.4109589 
15 : 0.4246575 
16 : 0.4383562 
16.5 : 0.4520548 
17.2 : 0.4657534 
19 : 0.4931507 
20 : 0.5068493 
20.7 : 0.5205479 
21 : 0.5342466 
21.6 : 0.5479452 
22 : 0.5616438 
24 : 0.6164384 
24.1 : 0.630137 
25 : 0.6575342 
26 : 0.6849315 
27 : 0.7260274 
28 : 0.7534247 
29 : 0.7671233 
30 : 0.8767123 
31.4 : 0.890411 
32 : 0.9041096 
33 : 0.9315068 
34 : 0.9589041 
34.8 : 0.9726027 
38 : 0.9863014 
46 : 1 
> cat("\n")

> 
> # Calcular media
> # Se calcula la media de 'distancia' usando la función manual
> media <- media_manual(s$distancia)
> # Mostrar la media
> cat("Media:", media, "\n")
Media: 18.53425 
> 
> # Varianza muestral y poblacional
> # Se calcula la varianza poblacional manual
> varianza_poblacional <- varianza_poblacional_manual(s$distancia)
> # Se calcula la varianza muestral manual
> varianza_muestral <- varianza_muestral_manual(s$distancia)
> # Se calcula la desviación estándar poblacional como raíz de la varianza poblacional
> desv_est_poblacional <- desv_estandar(varianza_poblacional)
> # Se calcula la desviación estándar muestral como raíz de la varianza muestral
> desv_est_muestral <- desv_estandar(varianza_muestral)
> 
> # Mostrar varianzas y desviaciones estándar
> cat("Varianza poblacional:", varianza_poblacional, "\n")
Varianza poblacional: 126.1587 
> cat("Desviación estándar poblacional:", desv_est_poblacional, "\n")
Desviación estándar poblacional: 11.23204 
> cat("Varianza muestral:", varianza_muestral, "\n")
Varianza muestral: 127.9109 
> cat("Desviación estándar muestral:", desv_est_muestral, "\n")
Desviación estándar muestral: 11.30977 
> 
> # ==============================================================================
> # EJERCICIO 2.2: ASOCIACIONES
> # ==============================================================================
> 
> # install.packages("Matrix")
> # install.packages("arules")
> library(Matrix)
> library(arules)
> 
> #Se define la muestra
> muestra<-Matrix(c(1,1,1,1,0,0, 1,1,0,1,1,0, 1,1,1,0,0,0, 1,0,1,1,1,0, 1,1,0,1,0,0, 0,0,1,0,0,0, 1,1,0,1,0,0, 0,0,0,0,1,1), 8, 6, byrow=TRUE, dimnames = list(c("suceso1", "suceso2", "suceso3", "suceso4", "suceso5", "suceso6", "suceso7", "suceso8"), c("Faros de Xenon", "Control de Velocidad", "Navegador", "Bluetooth", "Techo Solar", "Alarma")),sparse=TRUE)
> 
> #Se transforma el formato de la muestra
> muestrangCMatrix<-as(muestra, "nsparseMatrix")
> # muestrangCMatrix
> 
> #Se transpone la muestra
> trapmuestrangCMatrix<-t(muestrangCMatrix)
> # trapmuestrangCMatrix
> 
> #Se cambia el formato de la muestra transpuesta
> transacciones<-as(trapmuestrangCMatrix, "transactions")
> # transacciones
> 
> #Se muestra un resumen del estado de la muestra
> summary(transacciones)
transactions as itemMatrix in sparse format with
 8 rows (elements/itemsets/transactions) and
 6 columns (items) and a density of 0.5 

most frequent items:
      Faros de Xenon Control de Velocidad            Bluetooth            Navegador          Techo Solar              (Other) 
                   6                    5                    5                    4                    3                    1 

element (itemset/transaction) length distribution:
sizes
1 2 3 4 
1 1 3 3 

   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   1.00    2.75    3.00    3.00    4.00    4.00 

includes extended item information - examples:
                labels
1       Faros de Xenon
2 Control de Velocidad
3            Navegador

includes extended transaction information - examples:
  itemsetID
1   suceso1
2   suceso2
3   suceso3
> 
> #1ª FASE ----------------------------------------------------------------------------------------
> 
> #Se calcula la frecuencia
> frequency <- itemFrequency(transacciones, type ="absolute")
> # frequency
> 
> #Se define el umbra de aceptación de soporte
> support_threshold <- 0.5
> numero_sucesos <-length(transacciones)
> support_sucesos <-frequency/numero_sucesos
> # support_sucesos
> 
> #Se filtra los sucesos elementales que superan el umbral de soporte
> elementos_S_validos <- support_sucesos[support_sucesos >= support_threshold]
> # elementos_S_validos
> 
> 
> #2ªFASE -----------------------------------------------------------------------------------------
> #Se agrupan los sucesos elementales que superaron el umbral de soporte
> L1 <- c("Faros de Xenon", "Control de Velocidad", "Navegador", "Bluetooth")
> # L1
> 
> #Se agrupan en una lista 
> L1_lista <- lapply(L1, function(x) c(x))
> 
> #función que genera los sucesos candidatos de cada dimensión deseada
> generate_candidates <- function(L_prev) {
+    n <- length(L_prev)
+    if (n <= 1) return(list())     
+    k <- length(L_prev[[1]]) + 1
+    
+    # Que los sucesos candidatos estén ordenados
+    L_prev <- lapply(L_prev, sort)
+    candidates <- list()
+    
+    for (i in seq_len(n - 1)) {         
+      for (j in seq(i + 1, n)) {   
+        a <- L_prev[[i]]      
+        b <- L_prev[[j]]
+        
+        
+        if (k - 2 == 0 || all(a[1:(k - 2)] == b[1:(k - 2)])) {
+          new_set <- sort(unique(c(a, b)))
+          if (length(new_set) == k) {
+            candidates <- append(candidates, list(new_set))
+          }
+        }
+      }
+    }
+    
+    # eliminar duplicados (si hay)
+    if (length(candidates) > 0) {
+      candidates <- unique(lapply(candidates, function(x) paste(sort(x), collapse = ",")))
+      candidates <- lapply(candidates, function(x) strsplit(x, ",")[[1]])
+    }
+    return(candidates)
+ }
> 
> #sucesos candidatos de dimensión 2
> L2<- generate_candidates(L1_lista)
> # L2
> 
> #sucesos candidatos de dimensión 3
> L3 <- generate_candidates(L2)
> # L3
> 
> #sucesos candidatos de dimensión 4
> L4 <- generate_candidates(L3)
> # L4
> 
> 
> #3º FASE ----------------------------------------------------------------------------------------------------
> 
> #se crea diccionario para cambiar las palabras por números
> item_map <- c(
+    "Faros de Xenon" = 1,
+    "Control de Velocidad" = 2,
+    "Navegador" = 3,
+    "Bluetooth" = 4,
+    "Techo Solar" = 5,
+    "Alarma" = 6
+ )
> 
> #función que camibia las palabras de los sucesos por números con un orden ascendente los números
> encode_candidates <- function(candidates, mapping) {
+    lapply(candidates, function(subset) {
+      nums <- unname(mapping[subset])     
+      sort(nums)                         
+    })
+ }
> 
> #Se obtienes los sucesos candidatos codificados
> L2_numerico <- encode_candidates(L2, item_map)
> L3_numerico <- encode_candidates(L3, item_map)
> L4_numerico <- encode_candidates(L4, item_map)
> # L2_numerico
> 
> # 4º FASE -----------------------------------------------------------------------------------------------
> 
> #Se agrupan todos los candidatos en una lista común
> all_candidates <- c(L2_numerico, L3_numerico, L4_numerico)
> 
> #Se agrupan los sucesos candidatos en lista de cada uno con su dimensión
> L2_candidatos <- Filter(function(x) length(x) == 2, all_candidates)
> L3_candidatos <- Filter(function(x) length(x) == 3, all_candidates)
> L4_candidatos <- Filter(function(x) length(x) == 4, all_candidates)
> 
> 
> #función que crea el nodo árbol de cada suceso candidato para el hash tree
> make_node <- function(item = NULL, is_end = FALSE) {
+    node <- new.env(parent = emptyenv()) 
+    node$item <- item
+    node$children <- list() 
+    node$is_end <- is_end
+    node
+ }
> 
> 
> 
> #función que inserta las codificaciones de los sucesos candidatos, colocandolos en la posición correspondiente
> insert_candidate <- function(root, candidate) {
+    current <- root
+    for (it in candidate) {
+      key <- as.character(it)
+      if (!(key %in% names(current$children))) {
+        current$children[[key]] <- make_node(item = it, is_end = FALSE)
+      }
+      current <- current$children[[key]]
+    }
+    current$is_end <- TRUE
+    invisible(NULL)
+ }
> 
> 
> 
#función que inicia el proceso de creación de un hash tree
build_tree <- function(candidates) {
   root <- make_node(item = NULL, is_end = FALSE)
   for (cand in candidates) {
     insert_candidate(root, cand)
   }
   root
}
# función para imprimir el hash tree
print_tree <- function(node, depth = 0) {
   indent <- paste(rep("  ", depth), collapse = "")
   if (is.null(node$item)) {
     cat("(root)\n")
   } else {
     cat(indent, "- ", node$item, if (node$is_end) " [end]\n" else "\n", sep = "")
   }
   if (length(node$children) > 0) {
     keys <- as.integer(names(node$children))
     keys <- sort(keys, na.last = TRUE)
     for (k in as.character(keys)) {
       print_tree(node$children[[k]], depth + 1)
     }
   }
}
#Se crean los hash trees de los sucesos candidatos para cada dimensión
arbol_L2_candidatos <- build_tree(L2_candidatos)
arbol_L3_candidatos <- build_tree(L3_candidatos)
arbol_L4_candidatos <- build_tree(L4_candidatos) 
#Se imprime uno de los árboles
print_tree(arbol_L2_candidatos)
#Se crean los árboles de los conjuntos de la muestra para cada dimensión
#Se transforman los elementos del conjunto de la muestra en su versión númerica y ordenada
transactions_num <- apply(muestra, 1, function(row) {
   items <- names(row[row == 1])
   nums <- unname(item_map[items])
   sort(nums)
})
# transactions_num
# función que genera todas la combinaciones posibles de un conjunto numérico de la muestra en la dimensión deseada
generate_subsets <- function(items, k) {
   if (length(items) < k) return(list())
   combn(items, k, simplify = FALSE)
}
#Se crean las combinaciones posibles para cada conjunto de la muestra
transaction_subsets <- lapply(transactions_num, function(items) {
   list(
     C2 = generate_subsets(items, 2),
     C3 = generate_subsets(items, 3),
     C4 = generate_subsets(items, 4)
   )
})
#Se usa la función build tree sobre cada una de las combinaciones de los sucesos de la muestra
all_trees <- lapply(transaction_subsets, function(subs) {
   list(
     tree_C2 = if (length(subs$C2) > 0) build_tree(subs$C2) else NULL,
     tree_C3 = if (length(subs$C3) > 0) build_tree(subs$C3) else NULL,
     tree_C4 = if (length(subs$C4) > 0) build_tree(subs$C4) else NULL
   )
})
#Se imprime el árbol de dimensión 2 del suceso 1 de la muestra
print_tree(all_trees$suceso1$tree_C2)
#5º FASE ------------------------------------------------------------------
# Función que recoje todos las hojas del árbol para posteriormente poder contar las apariciones
get_leaf_paths <- function(node, current_path = integer()) {
   paths <- list()
   if (!is.null(node$item)) {
     current_path <- c(current_path, node$item)
   }
   if (node$is_end) {
     paths <- append(paths, list(current_path))
   }
   if (length(node$children) > 0) {
     for (child in node$children) {
       paths <- append(paths, get_leaf_paths(child, current_path))
     }
   }
   paths
}
#Se obtienen las hojas del árbol suceso candidato de dimensión 2
hojas_L2_candidato <- get_leaf_paths(arbol_L2_candidatos)
# hojas_L2_candidato
#Función que comprueba si existe una de las hojas de los árboles de los sucesos candidatos en un árbol
path_in_tree <- function(tree, path) {
   current <- tree
   for (item in path) {
     key <- as.character(item)
     if (!(key %in% names(current$children))) {
       return(FALSE)
     }
     current <- current$children[[key]]
   }
   return(TRUE)
}
#función que cuenta el número de apariciones de las hojas de los sucesos candidatos en los árboles de la muestra
count_supports <- function(candidate_tree, sample_trees_by_level) {
   candidate_paths <- get_leaf_paths(candidate_tree)
   supports <- numeric(length(candidate_paths))
   for (i in seq_along(candidate_paths)) {
     path <- candidate_paths[[i]]
     supports[i] <- sum(sapply(sample_trees_by_level, function(trees) {
       tree_level <- NULL
       k <- length(path)
       if (k == 2) tree_level <- trees$tree_C2
       else if (k == 3) tree_level <- trees$tree_C3
       else if (k == 4) tree_level <- trees$tree_C4
       if (is.null(tree_level)) return(FALSE)
       path_in_tree(tree_level, path)
     }))
   }
   data.frame(
     itemset = sapply(candidate_paths, function(p) paste(p, collapse = ",")),
     support = supports
   )
}
#Se obtienen los soportes de cada dimensión de los árboles candidatos
soporte_arbol_L2 <- count_supports(arbol_L2_candidatos, all_trees)
soporte_arbol_L3 <- count_supports(arbol_L3_candidatos, all_trees)
soporte_arbol_L4 <- count_supports(arbol_L4_candidatos, all_trees)
#Se imprimen los soportes de los árboles candidatos
soporte_arbol_L2
soporte_arbol_L3
soporte_arbol_L4
#función que filtra los sosportes de los árboles que superan el umbral
filter_by_threshold <- function(support_df, threshold, total_tx) {
   support_df$support_ratio <- support_df$support / total_tx
   subset(support_df, support_ratio >= threshold)
}
#Se obtienen los árboles con los elementos que superan el umbral de soporte
L2_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L2, support_threshold, numero_sucesos)
L3_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L3, support_threshold, numero_sucesos)
L4_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L4, support_threshold, numero_sucesos)
Se imprimen los árboles sucesos candidatos despues de observar cuales superan el soporte
L2_candidatos_post_arbol
L3_candidatos_post_arbol
L4_candidatos_post_arbol
#6ª FASE--------------------------------------------------------------------------------------------------
#Se revierten los números a palabras
item_map_rev <- setNames(names(item_map), item_map)
#función que genera las asociaciones posibles para cada suceso candidatos
generate_associations <- function(itemset) {
 k <- length(itemset)
   associations <- list()
   if (k < 2) return(associations)
   all_subsets <- unlist(lapply(1:(k - 1), function(i) combn(itemset, i, simplify = FALSE)), recursive = FALSE)
   for (lhs in all_subsets) {
     rhs <- setdiff(itemset, lhs)
     associations <- append(associations, list(list(lhs = lhs, rhs = rhs)))
   }
   associations
}
#convierte el texto a un vector numérico
split_itemset <- function(s) as.integer(unlist(strsplit(s, ",")))
#función que orquesta todo el proceso de creación de las asociaciones
create_associations_from_L <- function(L_df) {
 if (nrow(L_df) == 0) return(data.frame())
   all_associations <- list()
   for (i in seq_len(nrow(L_df))) {
     itemset <- split_itemset(L_df$itemset[i])
     associations <- generate_associations(itemset)
     all_associations <- append(all_associations, lapply(associations, function(r) {
       data.frame(
         lhs = paste(item_map_rev[as.character(sort(r$lhs))], collapse = ", "),
         rhs = paste(item_map_rev[as.character(sort(r$rhs))], collapse = ", "),
         k = length(itemset),
         support = L_df$support[i],
         support_ratio = L_df$support_ratio[i],
         stringsAsFactors = FALSE
       )
     }))
   }
   do.call(rbind, all_associations)
}
#Se crean las asociaciones
associaciones_L2 <- create_associations_from_L(L2_candidatos_post_arbol)
associaciones_L3 <- create_associations_from_L(L3_candidatos_post_arbol)
associaciones_L4 <- create_associations_from_L(L4_candidatos_post_arbol)
#Se imprimen las asociaciones creadas para la dimensión 2
associaciones_L2
#7ª FASE -----------------------------------------------------------------------------------
#Se define el umbral de confianza
confidence_threshold <- 0.8
#función que ayuda a crear la tabla de búsqueda convirtiendo los números a palabras
convert_numeric_str_to_text_str <- function(num_str, map_rev) {
   nums_numeric <- split_itemset(num_str) 
   nums_char <- as.character(nums_numeric)
   names <- unname(map_rev[nums_char])
   paste(names, collapse = ", ") 
}
#Se crea data frame para usarlo de búsqueda para la dimensión 1
soporte_L1_map_df <- data.frame(
   lhs_str = names(frequency),
   lhs_support = as.integer(frequency),
   stringsAsFactors = FALSE
)
#Se crea data frame para usarlo de búsqueda para la dimensión 2
soporte_L2_map_df <- data.frame(
   lhs_str = sapply(soporte_arbol_L2$itemset, convert_numeric_str_to_text_str, map_rev = item_map_rev),
   lhs_support = soporte_arbol_L2$support,
   stringsAsFactors = FALSE
)
#Se crea data frame para usarlo de búsqueda para la dimensión 3
soporte_L3_map_df <- data.frame(
   lhs_str = sapply(soporte_arbol_L3$itemset, convert_numeric_str_to_text_str, map_rev = item_map_rev),
   lhs_support = soporte_arbol_L3$support,
   stringsAsFactors = FALSE
)
#Se combinan tosas las anteriores en una sola tabla maestra
master_support_lookup <- rbind(soporte_L1_map_df, soporte_L2_map_df, soporte_L3_map_df)
master_support_lookup <- na.omit(master_support_lookup)
#Función que devuelve los valores de confianza para cada regla de asociación
calculate_and_filter_confidence <- function(associations_df, support_lookup, threshold) {
   if (nrow(associations_df) == 0) {
     return(data.frame(
       lhs = character(),
       rhs = character(),
       k = integer(),
       support_ratio = numeric(),
       confidence = numeric(),
       stringsAsFactors = FALSE
     ))
   }
   merged_df <- merge(associations_df, support_lookup, by.x = "lhs", by.y = "lhs_str", all.x = TRUE)
   merged_df$lhs_support[is.na(merged_df$lhs_support)] <- 0
   merged_df$confidence <- merged_df$support / merged_df$lhs_support
   merged_df$confidence[is.nan(merged_df$confidence)] <- 0
   strong_rules <- merged_df[, c("lhs", "rhs", "k", "support_ratio", "confidence")]
   strong_rules[order(-strong_rules$confidence), ]
}
#Se obtienen las asociaciones con las confianzas
reglas_fuertes_L2 <- calculate_and_filter_confidence(associaciones_L2, master_support_lookup, confidence_threshold)
reglas_fuertes_L3 <- calculate_and_filter_confidence(associaciones_L3, master_support_lookup, confidence_threshold)
reglas_fuertes_L4 <- calculate_and_filter_confidence(associaciones_L4, master_support_lookup, confidence_threshold)
# Filtrado final, se obtienen las reglas de asociación que superan el umbral de confianza
reglas_finales_L2 <- subset(reglas_fuertes_L2, confidence >= confidence_threshold)
reglas_finales_L3 <- subset(reglas_fuertes_L3, confidence >= confidence_threshold)
reglas_finales_L4 <- subset(reglas_fuertes_L4, confidence >= confidence_threshold)
print("--- Reglas que superan el umbral de confianza (0.8) ---")
print(reglas_finales_L2)
print(reglas_finales_L3)
print(reglas_finales_L4)
# ==============================================================================
# EJERCICIO 2.3: Análisis de detección de datos anómalos utilizando técnicas con base estadística.
# ==============================================================================
# CREACIÓN DEL CONJUNTO DE DATOS.
# Se crea un data frame con dos variables: Velocidad y Temperatura
# Cada fila representa una observación independiente
datos <- data.frame(
  Velocidad = c(10,8,13,9,11,14,6,4,12,7,5),
  Temperatura = c(7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73)
)
# FUNCIONES AUXILIARES BÁSICAS.
# Contar elementos manualmente
contar_elementos <- function(x) {
  n <- 0
  for (._ in x) n <- n + 1 # Incrementa n por cada elemento
  n
}
# Suma manual
mi_suma <- function(x) {
  total <- 0
  for (valor in x) total <- total + valor # Suma acumulativa de los valores
  total
}
# Media manual
media_manual <- function(x) {
  suma <- mi_suma(x)
  n <- contar_elementos(x)
  suma / n
}
# Varianza manual
varianza_manual <- function(x) {
  n <- contar_elementos(x)     # Número de elementos
  media <- media_manual(x)     # Media del vector
  suma <- 0
  for (v in x) suma <- suma + (v - media)^2   # Suma de desviaciones al cuadrado
  suma / n                   # Varianza = suma de cuadrados / n
}
# Desviación típica manual
desviacion_manual <- function(x) {
  sqrt(varianza_manual(x))
}
#FUNCIONES PARA CADA MÉTODO.
# --------------------------------------------------------------------------
# CAJA Y BIGOTES
# --------------------------------------------------------------------------
# Método IQR manual
detectar_outliers_iqr <- function(x) {
  resumen <- fivenum(x)      # Calcula los cinco números resumen: min, Q1, mediana, Q3, max
  Q1 <- resumen[2]           # Primer cuartil
  Q3 <- resumen[4]           # Tercer cuartil
  IQRv <- Q3 - Q1            # Rango intercuartílico
  lim_inf <- Q1 - 1.5 * IQRv # Límite inferior para detectar outliers
  lim_sup <- Q3 + 1.5 * IQRv # Límite superior para detectar outliers
  cat("\n--- DETECCIÓN OUTLIERS IQR ---\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  i <- 1
  hay_outliers <- FALSE
  for (v in x) {
    if (v < lim_inf || v > lim_sup) { # Si el valor está fuera de los límites
      cat("Índice:", i, "→ Valor =", v, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}
# --------------------------------------------------------------------------
# DESVIACIÓN TÍPICA
# --------------------------------------------------------------------------
# Método de la desviación típica manual
detectar_outliers_sd <- function(x, d = 2) {
  media <- media_manual(x)
  desv <- desviacion_manual(x)
  lim_inf <- media - d * desv
  lim_sup <- media + d * desv
  cat("\n--- DETECCIÓN OUTLIERS DESVIACIÓN TÍPICA ---\n")
  cat("Media:", media, "\n")
  cat("Desviación típica:", desv, "\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  i <- 1
  hay_outliers <- FALSE
  for (valor in x) {
    if (valor < lim_inf || valor > lim_sup) {
      cat("Índice:", i, "→ Valor =", valor, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}
# --------------------------------------------------------------------------
# REGRESIÓN
# --------------------------------------------------------------------------
# Método de regresión manual con detección por residuos
detectar_outliers_regresion <- function(x, y, d = 2) {
  n <- contar_elementos(x)  # Número de observaciones
  media_x <- media_manual(x)
  media_y <- media_manual(y)
  # Calcular los coeficientes de la recta de regresión y = b0 + b1*x
  num <- 0
  den <- 0
  for (i in seq(n)) {
    num <- num + (x[i] - media_x) * (y[i] - media_y)
    den <- den + (x[i] - media_x)^2
  }
  b1 <- num / den # Pendiente
  b0 <- media_y - b1 * media_x
  # Calcular residuos (diferencia entre y observado y y estimado)
  residuos <- numeric(n)
  for (i in seq(n)) {
    y_est <- b0 + b1 * x[i]
    residuos[i] <- y[i] - y_est
  }
  # Calcular error estándar de residuos
  suma_res <- 0
  for (r in residuos) suma_res <- suma_res + r^2
  error_est <- sqrt(suma_res / n)
  cat("\n--- DETECCIÓN OUTLIERS REGRESIÓN ---\n")
  cat("Ecuación: y =", round(b0, 4), "+", round(b1, 4), "* x\n")
  cat("Error estándar de residuos:", round(error_est, 4), "\n")
  i <- 1
  hay_outliers <- FALSE
  for (r in residuos) {
    if (abs(r) > d * error_est) { # Si el residuo supera d veces el error estándar
      cat("Índice:", i, "→ Residuo =", round(r, 4), "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers en los residuos.\n")
}
# APLICACIÓN DE LOS MÉTODOS
detectar_outliers_iqr(datos$Velocidad)
detectar_outliers_sd(datos$Temperatura)
detectar_outliers_regresion(datos$Velocidad, datos$Temperatura)
# ==============================================================================
# EJERCICIO 2.4: DETECCIÓN DE OUTLIERS MANUAL (K-NN y LOF)
# ==============================================================================
# --- 0. Carga de Datos ---
# Se asume que 'seminarios.txt' está en el directorio de trabajo.
if (!exists("s_bio")) {
  s_bio <- read.table("seminarios.txt", header = TRUE)
}
cat(">> Conjunto de datos (Asistencia):\n")
print(s_bio)
# Preparación común
datos_m <- as.matrix(s_bio)
n <- nrow(datos_m)
# ==============================================================================
# PARTE 1: K-NN MANUAL (Proximidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 1: K-NN MANUAL (Proximidad)\n")
cat("********************************************************************\n")
# Parámetros
K_knn <- 3
UMBRAL_DIST_KNN <- 5
# --- Paso 1: Cálculo Manual Matriz Distancias (Euclídea) ---
cat("\n[Paso 1] Matriz de Distancias Euclídeas:\n")
matriz_dist_euclidea <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = sqrt( (x1-x2)^2 + (y1-y2)^2 )
    matriz_dist_euclidea[i, j] <- sqrt((datos_m[i,1] - datos_m[j,1])^2 + 
                                       (datos_m[i,2] - datos_m[j,2])^2)
  }
}
print(round(matriz_dist_euclidea, 2))
# --- Paso 2: Análisis de Vecinos y Detección ---
cat("\n[Paso 2 & 3] Análisis de Vecindad (K =", K_knn, ") y Detección:\n")
for (i in 1:n) {
  dists_punto <- matriz_dist_euclidea[i, ]
  orden_vecinos <- order(dists_punto)
  # Los vecinos reales empiezan en el índice 2 (el 1 es el propio punto)
  indices_k_vecinos <- orden_vecinos[2:(K_knn + 1)]
  dist_k_esimo <- dists_punto[orden_vecinos[K_knn + 1]]
  # Mostrar detalle de los vecinos
  cat("\n--- Analizando Punto P", i, " ---\n", sep="")
  # Desglose de los 3 vecinos más cercanos
  for (k in 1:K_knn) {
     vecino_idx <- orden_vecinos[k+1]
     cat("   ", k, "º Vecino más cercano: P", vecino_idx, 
         " (Distancia: ", round(dists_punto[vecino_idx], 2), ")\n", sep="")
  }
  # Decisión final para el punto
  es_outlier <- dist_k_esimo > UMBRAL_DIST_KNN
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER!" else "-> Normal"
  cat(">> CONCLUSIÓN P", i, ": Distancia al 3er vecino = ", 
      round(dist_k_esimo, 2), " ", estado, "\n", sep="")
}
# ==============================================================================
# PARTE 2: LOF MANUAL (Densidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 2: LOF MANUAL (Densidad)\n")
cat("********************************************************************\n")
# Parámetros
K_lof <- 3
UMBRAL_DRM <- 0.8
# --- Paso Previo: Matriz Distancias Manhattan  ---
cat("\n[Paso Previo] Recálculo con Distancia Manhattan (para LOF):\n")
matriz_dist_manhattan <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = |x1-x2| + |y1-y2|
    matriz_dist_manhattan[i, j] <- abs(datos_m[i,1] - datos_m[j,1]) + 
                                   abs(datos_m[i,2] - datos_m[j,2])
  }
}
print(matriz_dist_manhattan)
# --- FASE A: Cálculo de Densidades Locales ---
cat("\n[FASE A] Cálculo de Densidad Local (d) para cada punto:\n")
cat("Fórmula: d(Pi) = ( Suma_distancias_a_K_vecinos / K )^-1\n\n")
densidad_local <- numeric(n)
vecinos_indices_lista <- vector("list", n) # Necesario para Fase B
for (i in 1:n) {
  dists <- matriz_dist_manhattan[i, ]
  orden <- order(dists)
  # Identificar los K vecinos
  mis_vecinos_idx <- orden[2:(K_lof + 1)]
  vecinos_indices_lista[[i]] <- mis_vecinos_idx
  # Suma de distancias
  suma_dist <- sum(dists[mis_vecinos_idx])
  # Cálculo de densidad
  densidad_local[i] <- (suma_dist / K_lof)^-1
  # Salida detallada
  vecinos_str <- paste("P", mis_vecinos_idx, sep="", collapse=", ")
  cat("P", i, ": Vecinos {", vecinos_str, "} | Suma Distancias: ", suma_dist,
      " | Densidad d(P", i, "): ", round(densidad_local[i], 4), "\n", sep="")
}
# --- FASE B: Cálculo de Densidad Relativa Media (drm) ---
cat("\n[FASE B] Cálculo de Densidad Relativa Media (drm):\n")
cat("Fórmula: drm(Pi) = d(Pi) / Media( d(vecinos_de_Pi) )\n\n")
drm_scores <- numeric(n)
for (i in 1:n) {
  # 1. Densidad propia
  mi_densidad <- densidad_local[i]
  # 2. Densidades de mis vecinos (recuperadas de la lista guardada en Fase A)
  indices_mis_vecinos <- vecinos_indices_lista[[i]]
  densidades_vecinos <- densidad_local[indices_mis_vecinos]
  # 3. Media de las densidades de los vecinos
  media_dens_vecinos <- mean(densidades_vecinos)
  # 4. Cálculo del drm
  drm_scores[i] <- mi_densidad / media_dens_vecinos
  # Salida detallada mostrando la comparación
  cat("P", i, " -> Mi Densidad: ", round(mi_densidad, 3), 
      " | Media Dens. Vecinos (P", paste(indices_mis_vecinos, collapse=",P"), 
      "): ", round(media_dens_vecinos, 3), 
      " | drm: ", round(drm_scores[i], 4), "\n", sep="")
}
# --- FASE C: Detección Final ---
cat("\n[FASE C] Resultados Finales LOF (Umbral drm <", UMBRAL_DRM, "):\n", sep="")
for (i in 1:n) {
  es_outlier <- drm_scores[i] < UMBRAL_DRM
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER! (Densidad relativa muy baja)" else "-> Normal"
  cat(sprintf("Punto P%d | drm = %.4f \t%s\n", i, drm_scores[i], estado))
}
cat("\n********************************************************************\n")
cat(" FIN DEL ANÁLISIS MANUAL EJERCICIO 2.4\n")
cat("********************************************************************\n")
