   for (it in candidate) {
     key <- as.character(it)
     if (!(key %in% names(current$children))) {
       current$children[[key]] <- make_node(item = it, is_end = FALSE)
     }
     current <- current$children[[key]]
   }
   current$is_end <- TRUE
   invisible(NULL)
}
#función que inicia el proceso de creación de un hash tree
build_tree <- function(candidates) {
   root <- make_node(item = NULL, is_end = FALSE)
   for (cand in candidates) {
     insert_candidate(root, cand)
   }
   root
}
# función para imprimir el hash tree
print_tree <- function(node, depth = 0) {
   indent <- paste(rep("  ", depth), collapse = "")
   if (is.null(node$item)) {
     cat("(root)\n")
   } else {
     cat(indent, "- ", node$item, if (node$is_end) " [end]\n" else "\n", sep = "")
   }
   if (length(node$children) > 0) {
     keys <- as.integer(names(node$children))
     keys <- sort(keys, na.last = TRUE)
     for (k in as.character(keys)) {
       print_tree(node$children[[k]], depth + 1)
     }
   }
}
#Se crean los hash trees de los sucesos candidatos para cada dimensión
arbol_L2_candidatos <- build_tree(L2_candidatos)
arbol_L3_candidatos <- build_tree(L3_candidatos)
arbol_L4_candidatos <- build_tree(L4_candidatos) 
#Se imprime uno de los árboles
print_tree(arbol_L2_candidatos)
#Se crean los árboles de los conjuntos de la muestra para cada dimensión
#Se transforman los elementos del conjunto de la muestra en su versión númerica y ordenada
transactions_num <- apply(muestra, 1, function(row) {
   items <- names(row[row == 1])
   nums <- unname(item_map[items])
   sort(nums)
})
# transactions_num
# función que genera todas la combinaciones posibles de un conjunto numérico de la muestra en la dimensión deseada
generate_subsets <- function(items, k) {
   if (length(items) < k) return(list())
   combn(items, k, simplify = FALSE)
}
#Se crean las combinaciones posibles para cada conjunto de la muestra
transaction_subsets <- lapply(transactions_num, function(items) {
   list(
     C2 = generate_subsets(items, 2),
     C3 = generate_subsets(items, 3),
     C4 = generate_subsets(items, 4)
   )
})
#Se usa la función build tree sobre cada una de las combinaciones de los sucesos de la muestra
all_trees <- lapply(transaction_subsets, function(subs) {
   list(
     tree_C2 = if (length(subs$C2) > 0) build_tree(subs$C2) else NULL,
     tree_C3 = if (length(subs$C3) > 0) build_tree(subs$C3) else NULL,
     tree_C4 = if (length(subs$C4) > 0) build_tree(subs$C4) else NULL
   )
})
#Se imprime el árbol de dimensión 2 del suceso 1 de la muestra
print_tree(all_trees$suceso1$tree_C2)
#5º FASE ------------------------------------------------------------------
# Función que recoje todos las hojas del árbol para posteriormente poder contar las apariciones
get_leaf_paths <- function(node, current_path = integer()) {
   paths <- list()
   if (!is.null(node$item)) {
     current_path <- c(current_path, node$item)
   }
   if (node$is_end) {
     paths <- append(paths, list(current_path))
   }
   if (length(node$children) > 0) {
     for (child in node$children) {
       paths <- append(paths, get_leaf_paths(child, current_path))
     }
   }
   paths
}
#Se obtienen las hojas del árbol suceso candidato de dimensión 2
hojas_L2_candidato <- get_leaf_paths(arbol_L2_candidatos)
# hojas_L2_candidato
#Función que comprueba si existe una de las hojas de los árboles de los sucesos candidatos en un árbol
path_in_tree <- function(tree, path) {
   current <- tree
   for (item in path) {
     key <- as.character(item)
     if (!(key %in% names(current$children))) {
       return(FALSE)
     }
     current <- current$children[[key]]
   }
   return(TRUE)
}
#función que cuenta el número de apariciones de las hojas de los sucesos candidatos en los árboles de la muestra
count_supports <- function(candidate_tree, sample_trees_by_level) {
   candidate_paths <- get_leaf_paths(candidate_tree)
   supports <- numeric(length(candidate_paths))
   for (i in seq_along(candidate_paths)) {
     path <- candidate_paths[[i]]
     supports[i] <- sum(sapply(sample_trees_by_level, function(trees) {
       tree_level <- NULL
       k <- length(path)
       if (k == 2) tree_level <- trees$tree_C2
       else if (k == 3) tree_level <- trees$tree_C3
       else if (k == 4) tree_level <- trees$tree_C4
       if (is.null(tree_level)) return(FALSE)
       path_in_tree(tree_level, path)
     }))
   }
   data.frame(
     itemset = sapply(candidate_paths, function(p) paste(p, collapse = ",")),
     support = supports
   )
}
#Se obtienen los soportes de cada dimensión de los árboles candidatos
soporte_arbol_L2 <- count_supports(arbol_L2_candidatos, all_trees)
soporte_arbol_L3 <- count_supports(arbol_L3_candidatos, all_trees)
soporte_arbol_L4 <- count_supports(arbol_L4_candidatos, all_trees)
#Se imprimen los soportes de los árboles candidatos
soporte_arbol_L2
soporte_arbol_L3
soporte_arbol_L4
#función que filtra los sosportes de los árboles que superan el umbral
filter_by_threshold <- function(support_df, threshold, total_tx) {
   support_df$support_ratio <- support_df$support / total_tx
   subset(support_df, support_ratio >= threshold)
}
#Se obtienen los árboles con los elementos que superan el umbral de soporte
L2_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L2, support_threshold, numero_sucesos)
L3_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L3, support_threshold, numero_sucesos)
L4_candidatos_post_arbol <- filter_by_threshold(soporte_arbol_L4, support_threshold, numero_sucesos)
Se imprimen los árboles sucesos candidatos despues de observar cuales superan el soporte
L2_candidatos_post_arbol
L3_candidatos_post_arbol
L4_candidatos_post_arbol
#6ª FASE--------------------------------------------------------------------------------------------------
#Se revierten los números a palabras
item_map_rev <- setNames(names(item_map), item_map)
#función que genera las asociaciones posibles para cada suceso candidatos
generate_associations <- function(itemset) {
 k <- length(itemset)
   associations <- list()
   if (k < 2) return(associations)
   all_subsets <- unlist(lapply(1:(k - 1), function(i) combn(itemset, i, simplify = FALSE)), recursive = FALSE)
   for (lhs in all_subsets) {
     rhs <- setdiff(itemset, lhs)
     associations <- append(associations, list(list(lhs = lhs, rhs = rhs)))
   }
   associations
}
#convierte el texto a un vector numérico
split_itemset <- function(s) as.integer(unlist(strsplit(s, ",")))
#función que orquesta todo el proceso de creación de las asociaciones
create_associations_from_L <- function(L_df) {
 if (nrow(L_df) == 0) return(data.frame())
   all_associations <- list()
   for (i in seq_len(nrow(L_df))) {
     itemset <- split_itemset(L_df$itemset[i])
     associations <- generate_associations(itemset)
     all_associations <- append(all_associations, lapply(associations, function(r) {
       data.frame(
         lhs = paste(item_map_rev[as.character(sort(r$lhs))], collapse = ", "),
         rhs = paste(item_map_rev[as.character(sort(r$rhs))], collapse = ", "),
         k = length(itemset),
         support = L_df$support[i],
         support_ratio = L_df$support_ratio[i],
         stringsAsFactors = FALSE
       )
     }))
   }
   do.call(rbind, all_associations)
}
#Se crean las asociaciones
associaciones_L2 <- create_associations_from_L(L2_candidatos_post_arbol)
associaciones_L3 <- create_associations_from_L(L3_candidatos_post_arbol)
associaciones_L4 <- create_associations_from_L(L4_candidatos_post_arbol)
#Se imprimen las asociaciones creadas para la dimensión 2
associaciones_L2
#7ª FASE -----------------------------------------------------------------------------------
#Se define el umbral de confianza
confidence_threshold <- 0.8
#función que ayuda a crear la tabla de búsqueda convirtiendo los números a palabras
convert_numeric_str_to_text_str <- function(num_str, map_rev) {
   nums_numeric <- split_itemset(num_str) 
   nums_char <- as.character(nums_numeric)
   names <- unname(map_rev[nums_char])
   paste(names, collapse = ", ") 
}
#Se crea data frame para usarlo de búsqueda para la dimensión 1
soporte_L1_map_df <- data.frame(
   lhs_str = names(frequency),
   lhs_support = as.integer(frequency),
   stringsAsFactors = FALSE
)
#Se crea data frame para usarlo de búsqueda para la dimensión 2
soporte_L2_map_df <- data.frame(
   lhs_str = sapply(soporte_arbol_L2$itemset, convert_numeric_str_to_text_str, map_rev = item_map_rev),
   lhs_support = soporte_arbol_L2$support,
   stringsAsFactors = FALSE
)
#Se crea data frame para usarlo de búsqueda para la dimensión 3
soporte_L3_map_df <- data.frame(
   lhs_str = sapply(soporte_arbol_L3$itemset, convert_numeric_str_to_text_str, map_rev = item_map_rev),
   lhs_support = soporte_arbol_L3$support,
   stringsAsFactors = FALSE
)
#Se combinan tosas las anteriores en una sola tabla maestra
master_support_lookup <- rbind(soporte_L1_map_df, soporte_L2_map_df, soporte_L3_map_df)
master_support_lookup <- na.omit(master_support_lookup)
#Función que devuelve los valores de confianza para cada regla de asociación
calculate_and_filter_confidence <- function(associations_df, support_lookup, threshold) {
   if (nrow(associations_df) == 0) {
     return(data.frame(
       lhs = character(),
       rhs = character(),
       k = integer(),
       support_ratio = numeric(),
       confidence = numeric(),
       stringsAsFactors = FALSE
     ))
   }
   merged_df <- merge(associations_df, support_lookup, by.x = "lhs", by.y = "lhs_str", all.x = TRUE)
   merged_df$lhs_support[is.na(merged_df$lhs_support)] <- 0
   merged_df$confidence <- merged_df$support / merged_df$lhs_support
   merged_df$confidence[is.nan(merged_df$confidence)] <- 0
   strong_rules <- merged_df[, c("lhs", "rhs", "k", "support_ratio", "confidence")]
   strong_rules[order(-strong_rules$confidence), ]
}
#Se obtienen las asociaciones con las confianzas
reglas_fuertes_L2 <- calculate_and_filter_confidence(associaciones_L2, master_support_lookup, confidence_threshold)
reglas_fuertes_L3 <- calculate_and_filter_confidence(associaciones_L3, master_support_lookup, confidence_threshold)
reglas_fuertes_L4 <- calculate_and_filter_confidence(associaciones_L4, master_support_lookup, confidence_threshold)
# Filtrado final, se obtienen las reglas de asociación que superan el umbral de confianza
reglas_finales_L2 <- subset(reglas_fuertes_L2, confidence >= confidence_threshold)
reglas_finales_L3 <- subset(reglas_fuertes_L3, confidence >= confidence_threshold)
reglas_finales_L4 <- subset(reglas_fuertes_L4, confidence >= confidence_threshold)
print("--- Reglas que superan el umbral de confianza (0.8) ---")
print(reglas_finales_L2)
print(reglas_finales_L3)
print(reglas_finales_L4)
# ==============================================================================
# EJERCICIO 2.3: Análisis de detección de datos anómalos utilizando técnicas con base estadística.
# ==============================================================================
# CREACIÓN DEL CONJUNTO DE DATOS.
# Se crea un data frame con dos variables: Velocidad y Temperatura
# Cada fila representa una observación independiente
datos <- data.frame(
  Velocidad = c(10,8,13,9,11,14,6,4,12,7,5),
  Temperatura = c(7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73)
)
# FUNCIONES AUXILIARES BÁSICAS.
# Contar elementos manualmente
contar_elementos <- function(x) {
  n <- 0
  for (._ in x) n <- n + 1 # Incrementa n por cada elemento
  n
}
# Suma manual
mi_suma <- function(x) {
  total <- 0
  for (valor in x) total <- total + valor # Suma acumulativa de los valores
  total
}
# Media manual
media_manual <- function(x) {
  suma <- mi_suma(x)
  n <- contar_elementos(x)
  suma / n
}
# Varianza manual
varianza_manual <- function(x) {
  n <- contar_elementos(x)     # Número de elementos
  media <- media_manual(x)     # Media del vector
  suma <- 0
  for (v in x) suma <- suma + (v - media)^2   # Suma de desviaciones al cuadrado
  suma / n                   # Varianza = suma de cuadrados / n
}
# Desviación típica manual
desviacion_manual <- function(x) {
  sqrt(varianza_manual(x))
}
#FUNCIONES PARA CADA MÉTODO.
# --------------------------------------------------------------------------
# CAJA Y BIGOTES
# --------------------------------------------------------------------------
# Método IQR manual
detectar_outliers_iqr <- function(x) {
  resumen <- fivenum(x)      # Calcula los cinco números resumen: min, Q1, mediana, Q3, max
  Q1 <- resumen[2]           # Primer cuartil
  Q3 <- resumen[4]           # Tercer cuartil
  IQRv <- Q3 - Q1            # Rango intercuartílico
  lim_inf <- Q1 - 1.5 * IQRv # Límite inferior para detectar outliers
  lim_sup <- Q3 + 1.5 * IQRv # Límite superior para detectar outliers
  cat("\n--- DETECCIÓN OUTLIERS IQR ---\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  i <- 1
  hay_outliers <- FALSE
  for (v in x) {
    if (v < lim_inf || v > lim_sup) { # Si el valor está fuera de los límites
      cat("Índice:", i, "→ Valor =", v, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}
# --------------------------------------------------------------------------
# DESVIACIÓN TÍPICA
# --------------------------------------------------------------------------
# Método de la desviación típica manual
detectar_outliers_sd <- function(x, d = 2) {
  media <- media_manual(x)
  desv <- desviacion_manual(x)
  lim_inf <- media - d * desv
  lim_sup <- media + d * desv
  cat("\n--- DETECCIÓN OUTLIERS DESVIACIÓN TÍPICA ---\n")
  cat("Media:", media, "\n")
  cat("Desviación típica:", desv, "\n")
  cat("Límite inferior:", lim_inf, "\n")
  cat("Límite superior:", lim_sup, "\n")
  i <- 1
  hay_outliers <- FALSE
  for (valor in x) {
    if (valor < lim_inf || valor > lim_sup) {
      cat("Índice:", i, "→ Valor =", valor, "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers.\n")
}
# --------------------------------------------------------------------------
# REGRESIÓN
# --------------------------------------------------------------------------
# Método de regresión manual con detección por residuos
detectar_outliers_regresion <- function(x, y, d = 2) {
  n <- contar_elementos(x)  # Número de observaciones
  media_x <- media_manual(x)
  media_y <- media_manual(y)
  # Calcular los coeficientes de la recta de regresión y = b0 + b1*x
  num <- 0
  den <- 0
  for (i in seq(n)) {
    num <- num + (x[i] - media_x) * (y[i] - media_y)
    den <- den + (x[i] - media_x)^2
  }
  b1 <- num / den # Pendiente
  b0 <- media_y - b1 * media_x
  # Calcular residuos (diferencia entre y observado y y estimado)
  residuos <- numeric(n)
  for (i in seq(n)) {
    y_est <- b0 + b1 * x[i]
    residuos[i] <- y[i] - y_est
  }
  # Calcular error estándar de residuos
  suma_res <- 0
  for (r in residuos) suma_res <- suma_res + r^2
  error_est <- sqrt(suma_res / n)
  cat("\n--- DETECCIÓN OUTLIERS REGRESIÓN ---\n")
  cat("Ecuación: y =", round(b0, 4), "+", round(b1, 4), "* x\n")
  cat("Error estándar de residuos:", round(error_est, 4), "\n")
  i <- 1
  hay_outliers <- FALSE
  for (r in residuos) {
    if (abs(r) > d * error_est) { # Si el residuo supera d veces el error estándar
      cat("Índice:", i, "→ Residuo =", round(r, 4), "es un outlier\n")
      hay_outliers <- TRUE
    }
    i <- i + 1
  }
  if (!hay_outliers) cat("No se detectaron outliers en los residuos.\n")
}
# APLICACIÓN DE LOS MÉTODOS
detectar_outliers_iqr(datos$Velocidad)
detectar_outliers_sd(datos$Temperatura)
detectar_outliers_regresion(datos$Velocidad, datos$Temperatura)
# ==============================================================================
# EJERCICIO 2.4: DETECCIÓN DE OUTLIERS MANUAL (K-NN y LOF)
# ==============================================================================
# --- 0. Carga de Datos ---
# Se asume que 'seminarios.txt' está en el directorio de trabajo.
if (!exists("s_bio")) {
  s_bio <- read.table("seminarios.txt", header = TRUE)
}
cat(">> Conjunto de datos (Asistencia):\n")
print(s_bio)
# Preparación común
datos_m <- as.matrix(s_bio)
n <- nrow(datos_m)
# ==============================================================================
# PARTE 1: K-NN MANUAL (Proximidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 1: K-NN MANUAL (Proximidad)\n")
cat("********************************************************************\n")
# Parámetros
K_knn <- 3
UMBRAL_DIST_KNN <- 5
# --- Paso 1: Cálculo Manual Matriz Distancias (Euclídea) ---
cat("\n[Paso 1] Matriz de Distancias Euclídeas:\n")
matriz_dist_euclidea <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = sqrt( (x1-x2)^2 + (y1-y2)^2 )
    matriz_dist_euclidea[i, j] <- sqrt((datos_m[i,1] - datos_m[j,1])^2 + 
                                       (datos_m[i,2] - datos_m[j,2])^2)
  }
}
print(round(matriz_dist_euclidea, 2))
# --- Paso 2: Análisis de Vecinos y Detección ---
cat("\n[Paso 2 & 3] Análisis de Vecindad (K =", K_knn, ") y Detección:\n")
for (i in 1:n) {
  dists_punto <- matriz_dist_euclidea[i, ]
  orden_vecinos <- order(dists_punto)
  # Los vecinos reales empiezan en el índice 2 (el 1 es el propio punto)
  indices_k_vecinos <- orden_vecinos[2:(K_knn + 1)]
  dist_k_esimo <- dists_punto[orden_vecinos[K_knn + 1]]
  # Mostrar detalle de los vecinos
  cat("\n--- Analizando Punto P", i, " ---\n", sep="")
  # Desglose de los 3 vecinos más cercanos
  for (k in 1:K_knn) {
     vecino_idx <- orden_vecinos[k+1]
     cat("   ", k, "º Vecino más cercano: P", vecino_idx, 
         " (Distancia: ", round(dists_punto[vecino_idx], 2), ")\n", sep="")
  }
  # Decisión final para el punto
  es_outlier <- dist_k_esimo > UMBRAL_DIST_KNN
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER!" else "-> Normal"
  cat(">> CONCLUSIÓN P", i, ": Distancia al 3er vecino = ", 
      round(dist_k_esimo, 2), " ", estado, "\n", sep="")
}
# ==============================================================================
# PARTE 2: LOF MANUAL (Densidad) 
# ==============================================================================
cat("\n\n********************************************************************\n")
cat(" MÉTODO 2: LOF MANUAL (Densidad)\n")
cat("********************************************************************\n")
# Parámetros
K_lof <- 3
UMBRAL_DRM <- 0.8
# --- Paso Previo: Matriz Distancias Manhattan  ---
cat("\n[Paso Previo] Recálculo con Distancia Manhattan (para LOF):\n")
matriz_dist_manhattan <- matrix(0, nrow=n, ncol=n)
for (i in 1:n) {
  for (j in 1:n) {
    # d = |x1-x2| + |y1-y2|
    matriz_dist_manhattan[i, j] <- abs(datos_m[i,1] - datos_m[j,1]) + 
                                   abs(datos_m[i,2] - datos_m[j,2])
  }
}
print(matriz_dist_manhattan)
# --- FASE A: Cálculo de Densidades Locales ---
cat("\n[FASE A] Cálculo de Densidad Local (d) para cada punto:\n")
cat("Fórmula: d(Pi) = ( Suma_distancias_a_K_vecinos / K )^-1\n\n")
densidad_local <- numeric(n)
vecinos_indices_lista <- vector("list", n) # Necesario para Fase B
for (i in 1:n) {
  dists <- matriz_dist_manhattan[i, ]
  orden <- order(dists)
  # Identificar los K vecinos
  mis_vecinos_idx <- orden[2:(K_lof + 1)]
  vecinos_indices_lista[[i]] <- mis_vecinos_idx
  # Suma de distancias
  suma_dist <- sum(dists[mis_vecinos_idx])
  # Cálculo de densidad
  densidad_local[i] <- (suma_dist / K_lof)^-1
  # Salida detallada
  vecinos_str <- paste("P", mis_vecinos_idx, sep="", collapse=", ")
  cat("P", i, ": Vecinos {", vecinos_str, "} | Suma Distancias: ", suma_dist,
      " | Densidad d(P", i, "): ", round(densidad_local[i], 4), "\n", sep="")
}
# --- FASE B: Cálculo de Densidad Relativa Media (drm) ---
cat("\n[FASE B] Cálculo de Densidad Relativa Media (drm):\n")
cat("Fórmula: drm(Pi) = d(Pi) / Media( d(vecinos_de_Pi) )\n\n")
drm_scores <- numeric(n)
for (i in 1:n) {
  # 1. Densidad propia
  mi_densidad <- densidad_local[i]
  # 2. Densidades de mis vecinos (recuperadas de la lista guardada en Fase A)
  indices_mis_vecinos <- vecinos_indices_lista[[i]]
  densidades_vecinos <- densidad_local[indices_mis_vecinos]
  # 3. Media de las densidades de los vecinos
  media_dens_vecinos <- mean(densidades_vecinos)
  # 4. Cálculo del drm
  drm_scores[i] <- mi_densidad / media_dens_vecinos
  # Salida detallada mostrando la comparación
  cat("P", i, " -> Mi Densidad: ", round(mi_densidad, 3), 
      " | Media Dens. Vecinos (P", paste(indices_mis_vecinos, collapse=",P"), 
      "): ", round(media_dens_vecinos, 3), 
      " | drm: ", round(drm_scores[i], 4), "\n", sep="")
}
# --- FASE C: Detección Final ---
cat("\n[FASE C] Resultados Finales LOF (Umbral drm <", UMBRAL_DRM, "):\n", sep="")
for (i in 1:n) {
  es_outlier <- drm_scores[i] < UMBRAL_DRM
  estado <- if (es_outlier) "-> ¡DETECTADO COMO OUTLIER! (Densidad relativa muy baja)" else "-> Normal"
  cat(sprintf("Punto P%d | drm = %.4f \t%s\n", i, drm_scores[i], estado))
}
cat("\n********************************************************************\n")
cat(" FIN DEL ANÁLISIS MANUAL EJERCICIO 2.4\n")
cat("********************************************************************\n")
